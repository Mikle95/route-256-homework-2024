// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/1mikle1/homework/cart/internal/pkg/cart/repository.ICart -o i_cart_mock_test.go -n ICartMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/1mikle1/homework/cart/internal/pkg/cart/model"
)

// ICartMock implements mm_repository.ICart
type ICartMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, c2 model.CartItem) (c3 model.CartItem)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, c2 model.CartItem)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mICartMockAddItem

	funcDeleteItem          func(ctx context.Context, s1 model.Sku)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, s1 model.Sku)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mICartMockDeleteItem

	funcGetItems          func(ctx context.Context) (ca1 []model.CartItem)
	funcGetItemsOrigin    string
	inspectFuncGetItems   func(ctx context.Context)
	afterGetItemsCounter  uint64
	beforeGetItemsCounter uint64
	GetItemsMock          mICartMockGetItems
}

// NewICartMock returns a mock for mm_repository.ICart
func NewICartMock(t minimock.Tester) *ICartMock {
	m := &ICartMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mICartMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*ICartMockAddItemParams{}

	m.DeleteItemMock = mICartMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*ICartMockDeleteItemParams{}

	m.GetItemsMock = mICartMockGetItems{mock: m}
	m.GetItemsMock.callArgs = []*ICartMockGetItemsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mICartMockAddItem struct {
	optional           bool
	mock               *ICartMock
	defaultExpectation *ICartMockAddItemExpectation
	expectations       []*ICartMockAddItemExpectation

	callArgs []*ICartMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartMockAddItemExpectation specifies expectation struct of the ICart.AddItem
type ICartMockAddItemExpectation struct {
	mock               *ICartMock
	params             *ICartMockAddItemParams
	paramPtrs          *ICartMockAddItemParamPtrs
	expectationOrigins ICartMockAddItemExpectationOrigins
	results            *ICartMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// ICartMockAddItemParams contains parameters of the ICart.AddItem
type ICartMockAddItemParams struct {
	ctx context.Context
	c2  model.CartItem
}

// ICartMockAddItemParamPtrs contains pointers to parameters of the ICart.AddItem
type ICartMockAddItemParamPtrs struct {
	ctx *context.Context
	c2  *model.CartItem
}

// ICartMockAddItemResults contains results of the ICart.AddItem
type ICartMockAddItemResults struct {
	c3 model.CartItem
}

// ICartMockAddItemOrigins contains origins of expectations of the ICart.AddItem
type ICartMockAddItemExpectationOrigins struct {
	origin    string
	originCtx string
	originC2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mICartMockAddItem) Optional() *mICartMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for ICart.AddItem
func (mmAddItem *mICartMockAddItem) Expect(ctx context.Context, c2 model.CartItem) *mICartMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("ICartMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &ICartMockAddItemParams{ctx, c2}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for ICart.AddItem
func (mmAddItem *mICartMockAddItem) ExpectCtxParam1(ctx context.Context) *mICartMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ICartMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ICartMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectC2Param2 sets up expected param c2 for ICart.AddItem
func (mmAddItem *mICartMockAddItem) ExpectC2Param2(c2 model.CartItem) *mICartMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ICartMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ICartMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.c2 = &c2
	mmAddItem.defaultExpectation.expectationOrigins.originC2 = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the ICart.AddItem
func (mmAddItem *mICartMockAddItem) Inspect(f func(ctx context.Context, c2 model.CartItem)) *mICartMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for ICartMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by ICart.AddItem
func (mmAddItem *mICartMockAddItem) Return(c3 model.CartItem) *ICartMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &ICartMockAddItemResults{c3}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the ICart.AddItem method
func (mmAddItem *mICartMockAddItem) Set(f func(ctx context.Context, c2 model.CartItem) (c3 model.CartItem)) *ICartMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the ICart.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the ICart.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the ICart.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mICartMockAddItem) When(ctx context.Context, c2 model.CartItem) *ICartMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartMock.AddItem mock is already set by Set")
	}

	expectation := &ICartMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &ICartMockAddItemParams{ctx, c2},
		expectationOrigins: ICartMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up ICart.AddItem return parameters for the expectation previously defined by the When method
func (e *ICartMockAddItemExpectation) Then(c3 model.CartItem) *ICartMock {
	e.results = &ICartMockAddItemResults{c3}
	return e.mock
}

// Times sets number of times ICart.AddItem should be invoked
func (mmAddItem *mICartMockAddItem) Times(n uint64) *mICartMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of ICartMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mICartMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_repository.ICart
func (mmAddItem *ICartMock) AddItem(ctx context.Context, c2 model.CartItem) (c3 model.CartItem) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, c2)
	}

	mm_params := ICartMockAddItemParams{ctx, c2}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c3
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := ICartMockAddItemParams{ctx, c2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("ICartMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.c2 != nil && !minimock.Equal(*mm_want_ptrs.c2, mm_got.c2) {
				mmAddItem.t.Errorf("ICartMock.AddItem got unexpected parameter c2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originC2, *mm_want_ptrs.c2, mm_got.c2, minimock.Diff(*mm_want_ptrs.c2, mm_got.c2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("ICartMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the ICartMock.AddItem")
		}
		return (*mm_results).c3
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, c2)
	}
	mmAddItem.t.Fatalf("Unexpected call to ICartMock.AddItem. %v %v", ctx, c2)
	return
}

// AddItemAfterCounter returns a count of finished ICartMock.AddItem invocations
func (mmAddItem *ICartMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of ICartMock.AddItem invocations
func (mmAddItem *ICartMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to ICartMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mICartMockAddItem) Calls() []*ICartMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*ICartMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *ICartMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *ICartMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to ICartMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mICartMockDeleteItem struct {
	optional           bool
	mock               *ICartMock
	defaultExpectation *ICartMockDeleteItemExpectation
	expectations       []*ICartMockDeleteItemExpectation

	callArgs []*ICartMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartMockDeleteItemExpectation specifies expectation struct of the ICart.DeleteItem
type ICartMockDeleteItemExpectation struct {
	mock               *ICartMock
	params             *ICartMockDeleteItemParams
	paramPtrs          *ICartMockDeleteItemParamPtrs
	expectationOrigins ICartMockDeleteItemExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// ICartMockDeleteItemParams contains parameters of the ICart.DeleteItem
type ICartMockDeleteItemParams struct {
	ctx context.Context
	s1  model.Sku
}

// ICartMockDeleteItemParamPtrs contains pointers to parameters of the ICart.DeleteItem
type ICartMockDeleteItemParamPtrs struct {
	ctx *context.Context
	s1  *model.Sku
}

// ICartMockDeleteItemOrigins contains origins of expectations of the ICart.DeleteItem
type ICartMockDeleteItemExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mICartMockDeleteItem) Optional() *mICartMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for ICart.DeleteItem
func (mmDeleteItem *mICartMockDeleteItem) Expect(ctx context.Context, s1 model.Sku) *mICartMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("ICartMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &ICartMockDeleteItemParams{ctx, s1}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for ICart.DeleteItem
func (mmDeleteItem *mICartMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mICartMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ICartMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ICartMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectS1Param2 sets up expected param s1 for ICart.DeleteItem
func (mmDeleteItem *mICartMockDeleteItem) ExpectS1Param2(s1 model.Sku) *mICartMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ICartMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ICartMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteItem.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the ICart.DeleteItem
func (mmDeleteItem *mICartMockDeleteItem) Inspect(f func(ctx context.Context, s1 model.Sku)) *mICartMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for ICartMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by ICart.DeleteItem
func (mmDeleteItem *mICartMockDeleteItem) Return() *ICartMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}

	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the ICart.DeleteItem method
func (mmDeleteItem *mICartMockDeleteItem) Set(f func(ctx context.Context, s1 model.Sku)) *ICartMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the ICart.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the ICart.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Times sets number of times ICart.DeleteItem should be invoked
func (mmDeleteItem *mICartMockDeleteItem) Times(n uint64) *mICartMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of ICartMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mICartMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_repository.ICart
func (mmDeleteItem *ICartMock) DeleteItem(ctx context.Context, s1 model.Sku) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, s1)
	}

	mm_params := ICartMockDeleteItemParams{ctx, s1}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := ICartMockDeleteItemParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("ICartMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteItem.t.Errorf("ICartMock.DeleteItem got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("ICartMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteItem.funcDeleteItem != nil {
		mmDeleteItem.funcDeleteItem(ctx, s1)
		return
	}
	mmDeleteItem.t.Fatalf("Unexpected call to ICartMock.DeleteItem. %v %v", ctx, s1)

}

// DeleteItemAfterCounter returns a count of finished ICartMock.DeleteItem invocations
func (mmDeleteItem *ICartMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of ICartMock.DeleteItem invocations
func (mmDeleteItem *ICartMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to ICartMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mICartMockDeleteItem) Calls() []*ICartMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*ICartMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *ICartMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *ICartMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to ICartMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mICartMockGetItems struct {
	optional           bool
	mock               *ICartMock
	defaultExpectation *ICartMockGetItemsExpectation
	expectations       []*ICartMockGetItemsExpectation

	callArgs []*ICartMockGetItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartMockGetItemsExpectation specifies expectation struct of the ICart.GetItems
type ICartMockGetItemsExpectation struct {
	mock               *ICartMock
	params             *ICartMockGetItemsParams
	paramPtrs          *ICartMockGetItemsParamPtrs
	expectationOrigins ICartMockGetItemsExpectationOrigins
	results            *ICartMockGetItemsResults
	returnOrigin       string
	Counter            uint64
}

// ICartMockGetItemsParams contains parameters of the ICart.GetItems
type ICartMockGetItemsParams struct {
	ctx context.Context
}

// ICartMockGetItemsParamPtrs contains pointers to parameters of the ICart.GetItems
type ICartMockGetItemsParamPtrs struct {
	ctx *context.Context
}

// ICartMockGetItemsResults contains results of the ICart.GetItems
type ICartMockGetItemsResults struct {
	ca1 []model.CartItem
}

// ICartMockGetItemsOrigins contains origins of expectations of the ICart.GetItems
type ICartMockGetItemsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItems *mICartMockGetItems) Optional() *mICartMockGetItems {
	mmGetItems.optional = true
	return mmGetItems
}

// Expect sets up expected params for ICart.GetItems
func (mmGetItems *mICartMockGetItems) Expect(ctx context.Context) *mICartMockGetItems {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("ICartMock.GetItems mock is already set by Set")
	}

	if mmGetItems.defaultExpectation == nil {
		mmGetItems.defaultExpectation = &ICartMockGetItemsExpectation{}
	}

	if mmGetItems.defaultExpectation.paramPtrs != nil {
		mmGetItems.mock.t.Fatalf("ICartMock.GetItems mock is already set by ExpectParams functions")
	}

	mmGetItems.defaultExpectation.params = &ICartMockGetItemsParams{ctx}
	mmGetItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItems.expectations {
		if minimock.Equal(e.params, mmGetItems.defaultExpectation.params) {
			mmGetItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItems.defaultExpectation.params)
		}
	}

	return mmGetItems
}

// ExpectCtxParam1 sets up expected param ctx for ICart.GetItems
func (mmGetItems *mICartMockGetItems) ExpectCtxParam1(ctx context.Context) *mICartMockGetItems {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("ICartMock.GetItems mock is already set by Set")
	}

	if mmGetItems.defaultExpectation == nil {
		mmGetItems.defaultExpectation = &ICartMockGetItemsExpectation{}
	}

	if mmGetItems.defaultExpectation.params != nil {
		mmGetItems.mock.t.Fatalf("ICartMock.GetItems mock is already set by Expect")
	}

	if mmGetItems.defaultExpectation.paramPtrs == nil {
		mmGetItems.defaultExpectation.paramPtrs = &ICartMockGetItemsParamPtrs{}
	}
	mmGetItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItems
}

// Inspect accepts an inspector function that has same arguments as the ICart.GetItems
func (mmGetItems *mICartMockGetItems) Inspect(f func(ctx context.Context)) *mICartMockGetItems {
	if mmGetItems.mock.inspectFuncGetItems != nil {
		mmGetItems.mock.t.Fatalf("Inspect function is already set for ICartMock.GetItems")
	}

	mmGetItems.mock.inspectFuncGetItems = f

	return mmGetItems
}

// Return sets up results that will be returned by ICart.GetItems
func (mmGetItems *mICartMockGetItems) Return(ca1 []model.CartItem) *ICartMock {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("ICartMock.GetItems mock is already set by Set")
	}

	if mmGetItems.defaultExpectation == nil {
		mmGetItems.defaultExpectation = &ICartMockGetItemsExpectation{mock: mmGetItems.mock}
	}
	mmGetItems.defaultExpectation.results = &ICartMockGetItemsResults{ca1}
	mmGetItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItems.mock
}

// Set uses given function f to mock the ICart.GetItems method
func (mmGetItems *mICartMockGetItems) Set(f func(ctx context.Context) (ca1 []model.CartItem)) *ICartMock {
	if mmGetItems.defaultExpectation != nil {
		mmGetItems.mock.t.Fatalf("Default expectation is already set for the ICart.GetItems method")
	}

	if len(mmGetItems.expectations) > 0 {
		mmGetItems.mock.t.Fatalf("Some expectations are already set for the ICart.GetItems method")
	}

	mmGetItems.mock.funcGetItems = f
	mmGetItems.mock.funcGetItemsOrigin = minimock.CallerInfo(1)
	return mmGetItems.mock
}

// When sets expectation for the ICart.GetItems which will trigger the result defined by the following
// Then helper
func (mmGetItems *mICartMockGetItems) When(ctx context.Context) *ICartMockGetItemsExpectation {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("ICartMock.GetItems mock is already set by Set")
	}

	expectation := &ICartMockGetItemsExpectation{
		mock:               mmGetItems.mock,
		params:             &ICartMockGetItemsParams{ctx},
		expectationOrigins: ICartMockGetItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItems.expectations = append(mmGetItems.expectations, expectation)
	return expectation
}

// Then sets up ICart.GetItems return parameters for the expectation previously defined by the When method
func (e *ICartMockGetItemsExpectation) Then(ca1 []model.CartItem) *ICartMock {
	e.results = &ICartMockGetItemsResults{ca1}
	return e.mock
}

// Times sets number of times ICart.GetItems should be invoked
func (mmGetItems *mICartMockGetItems) Times(n uint64) *mICartMockGetItems {
	if n == 0 {
		mmGetItems.mock.t.Fatalf("Times of ICartMock.GetItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItems.expectedInvocations, n)
	mmGetItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItems
}

func (mmGetItems *mICartMockGetItems) invocationsDone() bool {
	if len(mmGetItems.expectations) == 0 && mmGetItems.defaultExpectation == nil && mmGetItems.mock.funcGetItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItems.mock.afterGetItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItems implements mm_repository.ICart
func (mmGetItems *ICartMock) GetItems(ctx context.Context) (ca1 []model.CartItem) {
	mm_atomic.AddUint64(&mmGetItems.beforeGetItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItems.afterGetItemsCounter, 1)

	mmGetItems.t.Helper()

	if mmGetItems.inspectFuncGetItems != nil {
		mmGetItems.inspectFuncGetItems(ctx)
	}

	mm_params := ICartMockGetItemsParams{ctx}

	// Record call args
	mmGetItems.GetItemsMock.mutex.Lock()
	mmGetItems.GetItemsMock.callArgs = append(mmGetItems.GetItemsMock.callArgs, &mm_params)
	mmGetItems.GetItemsMock.mutex.Unlock()

	for _, e := range mmGetItems.GetItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1
		}
	}

	if mmGetItems.GetItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItems.GetItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItems.GetItemsMock.defaultExpectation.params
		mm_want_ptrs := mmGetItems.GetItemsMock.defaultExpectation.paramPtrs

		mm_got := ICartMockGetItemsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItems.t.Errorf("ICartMock.GetItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItems.GetItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItems.t.Errorf("ICartMock.GetItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItems.GetItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItems.GetItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItems.t.Fatal("No results are set for the ICartMock.GetItems")
		}
		return (*mm_results).ca1
	}
	if mmGetItems.funcGetItems != nil {
		return mmGetItems.funcGetItems(ctx)
	}
	mmGetItems.t.Fatalf("Unexpected call to ICartMock.GetItems. %v", ctx)
	return
}

// GetItemsAfterCounter returns a count of finished ICartMock.GetItems invocations
func (mmGetItems *ICartMock) GetItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItems.afterGetItemsCounter)
}

// GetItemsBeforeCounter returns a count of ICartMock.GetItems invocations
func (mmGetItems *ICartMock) GetItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItems.beforeGetItemsCounter)
}

// Calls returns a list of arguments used in each call to ICartMock.GetItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItems *mICartMockGetItems) Calls() []*ICartMockGetItemsParams {
	mmGetItems.mutex.RLock()

	argCopy := make([]*ICartMockGetItemsParams, len(mmGetItems.callArgs))
	copy(argCopy, mmGetItems.callArgs)

	mmGetItems.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsDone returns true if the count of the GetItems invocations corresponds
// the number of defined expectations
func (m *ICartMock) MinimockGetItemsDone() bool {
	if m.GetItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsMock.invocationsDone()
}

// MinimockGetItemsInspect logs each unmet expectation
func (m *ICartMock) MinimockGetItemsInspect() {
	for _, e := range m.GetItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartMock.GetItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemsCounter := mm_atomic.LoadUint64(&m.afterGetItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsMock.defaultExpectation != nil && afterGetItemsCounter < 1 {
		if m.GetItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartMock.GetItems at\n%s", m.GetItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartMock.GetItems at\n%s with params: %#v", m.GetItemsMock.defaultExpectation.expectationOrigins.origin, *m.GetItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItems != nil && afterGetItemsCounter < 1 {
		m.t.Errorf("Expected call to ICartMock.GetItems at\n%s", m.funcGetItemsOrigin)
	}

	if !m.GetItemsMock.invocationsDone() && afterGetItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartMock.GetItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsMock.expectedInvocations), m.GetItemsMock.expectedInvocationsOrigin, afterGetItemsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ICartMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockGetItemsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ICartMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ICartMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockGetItemsDone()
}
