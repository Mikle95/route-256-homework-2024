// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/1mikle1/homework/cart/internal/pkg/cart/service.ILOMSService -o iloms_service_mock_test.go -n ILOMSServiceMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/1mikle1/homework/cart/internal/domain"
)

// ILOMSServiceMock implements mm_service.ILOMSService
type ILOMSServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckout          func(ctx context.Context, o1 domain.Order) (o2 domain.OID, err error)
	funcCheckoutOrigin    string
	inspectFuncCheckout   func(ctx context.Context, o1 domain.Order)
	afterCheckoutCounter  uint64
	beforeCheckoutCounter uint64
	CheckoutMock          mILOMSServiceMockCheckout

	funcStocksInfo          func(ctx context.Context, s1 domain.Sku) (u1 uint64, err error)
	funcStocksInfoOrigin    string
	inspectFuncStocksInfo   func(ctx context.Context, s1 domain.Sku)
	afterStocksInfoCounter  uint64
	beforeStocksInfoCounter uint64
	StocksInfoMock          mILOMSServiceMockStocksInfo
}

// NewILOMSServiceMock returns a mock for mm_service.ILOMSService
func NewILOMSServiceMock(t minimock.Tester) *ILOMSServiceMock {
	m := &ILOMSServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckoutMock = mILOMSServiceMockCheckout{mock: m}
	m.CheckoutMock.callArgs = []*ILOMSServiceMockCheckoutParams{}

	m.StocksInfoMock = mILOMSServiceMockStocksInfo{mock: m}
	m.StocksInfoMock.callArgs = []*ILOMSServiceMockStocksInfoParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mILOMSServiceMockCheckout struct {
	optional           bool
	mock               *ILOMSServiceMock
	defaultExpectation *ILOMSServiceMockCheckoutExpectation
	expectations       []*ILOMSServiceMockCheckoutExpectation

	callArgs []*ILOMSServiceMockCheckoutParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ILOMSServiceMockCheckoutExpectation specifies expectation struct of the ILOMSService.Checkout
type ILOMSServiceMockCheckoutExpectation struct {
	mock               *ILOMSServiceMock
	params             *ILOMSServiceMockCheckoutParams
	paramPtrs          *ILOMSServiceMockCheckoutParamPtrs
	expectationOrigins ILOMSServiceMockCheckoutExpectationOrigins
	results            *ILOMSServiceMockCheckoutResults
	returnOrigin       string
	Counter            uint64
}

// ILOMSServiceMockCheckoutParams contains parameters of the ILOMSService.Checkout
type ILOMSServiceMockCheckoutParams struct {
	ctx context.Context
	o1  domain.Order
}

// ILOMSServiceMockCheckoutParamPtrs contains pointers to parameters of the ILOMSService.Checkout
type ILOMSServiceMockCheckoutParamPtrs struct {
	ctx *context.Context
	o1  *domain.Order
}

// ILOMSServiceMockCheckoutResults contains results of the ILOMSService.Checkout
type ILOMSServiceMockCheckoutResults struct {
	o2  domain.OID
	err error
}

// ILOMSServiceMockCheckoutOrigins contains origins of expectations of the ILOMSService.Checkout
type ILOMSServiceMockCheckoutExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckout *mILOMSServiceMockCheckout) Optional() *mILOMSServiceMockCheckout {
	mmCheckout.optional = true
	return mmCheckout
}

// Expect sets up expected params for ILOMSService.Checkout
func (mmCheckout *mILOMSServiceMockCheckout) Expect(ctx context.Context, o1 domain.Order) *mILOMSServiceMockCheckout {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("ILOMSServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &ILOMSServiceMockCheckoutExpectation{}
	}

	if mmCheckout.defaultExpectation.paramPtrs != nil {
		mmCheckout.mock.t.Fatalf("ILOMSServiceMock.Checkout mock is already set by ExpectParams functions")
	}

	mmCheckout.defaultExpectation.params = &ILOMSServiceMockCheckoutParams{ctx, o1}
	mmCheckout.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckout.expectations {
		if minimock.Equal(e.params, mmCheckout.defaultExpectation.params) {
			mmCheckout.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckout.defaultExpectation.params)
		}
	}

	return mmCheckout
}

// ExpectCtxParam1 sets up expected param ctx for ILOMSService.Checkout
func (mmCheckout *mILOMSServiceMockCheckout) ExpectCtxParam1(ctx context.Context) *mILOMSServiceMockCheckout {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("ILOMSServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &ILOMSServiceMockCheckoutExpectation{}
	}

	if mmCheckout.defaultExpectation.params != nil {
		mmCheckout.mock.t.Fatalf("ILOMSServiceMock.Checkout mock is already set by Expect")
	}

	if mmCheckout.defaultExpectation.paramPtrs == nil {
		mmCheckout.defaultExpectation.paramPtrs = &ILOMSServiceMockCheckoutParamPtrs{}
	}
	mmCheckout.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckout.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckout
}

// ExpectO1Param2 sets up expected param o1 for ILOMSService.Checkout
func (mmCheckout *mILOMSServiceMockCheckout) ExpectO1Param2(o1 domain.Order) *mILOMSServiceMockCheckout {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("ILOMSServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &ILOMSServiceMockCheckoutExpectation{}
	}

	if mmCheckout.defaultExpectation.params != nil {
		mmCheckout.mock.t.Fatalf("ILOMSServiceMock.Checkout mock is already set by Expect")
	}

	if mmCheckout.defaultExpectation.paramPtrs == nil {
		mmCheckout.defaultExpectation.paramPtrs = &ILOMSServiceMockCheckoutParamPtrs{}
	}
	mmCheckout.defaultExpectation.paramPtrs.o1 = &o1
	mmCheckout.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmCheckout
}

// Inspect accepts an inspector function that has same arguments as the ILOMSService.Checkout
func (mmCheckout *mILOMSServiceMockCheckout) Inspect(f func(ctx context.Context, o1 domain.Order)) *mILOMSServiceMockCheckout {
	if mmCheckout.mock.inspectFuncCheckout != nil {
		mmCheckout.mock.t.Fatalf("Inspect function is already set for ILOMSServiceMock.Checkout")
	}

	mmCheckout.mock.inspectFuncCheckout = f

	return mmCheckout
}

// Return sets up results that will be returned by ILOMSService.Checkout
func (mmCheckout *mILOMSServiceMockCheckout) Return(o2 domain.OID, err error) *ILOMSServiceMock {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("ILOMSServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &ILOMSServiceMockCheckoutExpectation{mock: mmCheckout.mock}
	}
	mmCheckout.defaultExpectation.results = &ILOMSServiceMockCheckoutResults{o2, err}
	mmCheckout.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckout.mock
}

// Set uses given function f to mock the ILOMSService.Checkout method
func (mmCheckout *mILOMSServiceMockCheckout) Set(f func(ctx context.Context, o1 domain.Order) (o2 domain.OID, err error)) *ILOMSServiceMock {
	if mmCheckout.defaultExpectation != nil {
		mmCheckout.mock.t.Fatalf("Default expectation is already set for the ILOMSService.Checkout method")
	}

	if len(mmCheckout.expectations) > 0 {
		mmCheckout.mock.t.Fatalf("Some expectations are already set for the ILOMSService.Checkout method")
	}

	mmCheckout.mock.funcCheckout = f
	mmCheckout.mock.funcCheckoutOrigin = minimock.CallerInfo(1)
	return mmCheckout.mock
}

// When sets expectation for the ILOMSService.Checkout which will trigger the result defined by the following
// Then helper
func (mmCheckout *mILOMSServiceMockCheckout) When(ctx context.Context, o1 domain.Order) *ILOMSServiceMockCheckoutExpectation {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("ILOMSServiceMock.Checkout mock is already set by Set")
	}

	expectation := &ILOMSServiceMockCheckoutExpectation{
		mock:               mmCheckout.mock,
		params:             &ILOMSServiceMockCheckoutParams{ctx, o1},
		expectationOrigins: ILOMSServiceMockCheckoutExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckout.expectations = append(mmCheckout.expectations, expectation)
	return expectation
}

// Then sets up ILOMSService.Checkout return parameters for the expectation previously defined by the When method
func (e *ILOMSServiceMockCheckoutExpectation) Then(o2 domain.OID, err error) *ILOMSServiceMock {
	e.results = &ILOMSServiceMockCheckoutResults{o2, err}
	return e.mock
}

// Times sets number of times ILOMSService.Checkout should be invoked
func (mmCheckout *mILOMSServiceMockCheckout) Times(n uint64) *mILOMSServiceMockCheckout {
	if n == 0 {
		mmCheckout.mock.t.Fatalf("Times of ILOMSServiceMock.Checkout mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckout.expectedInvocations, n)
	mmCheckout.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckout
}

func (mmCheckout *mILOMSServiceMockCheckout) invocationsDone() bool {
	if len(mmCheckout.expectations) == 0 && mmCheckout.defaultExpectation == nil && mmCheckout.mock.funcCheckout == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckout.mock.afterCheckoutCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckout.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Checkout implements mm_service.ILOMSService
func (mmCheckout *ILOMSServiceMock) Checkout(ctx context.Context, o1 domain.Order) (o2 domain.OID, err error) {
	mm_atomic.AddUint64(&mmCheckout.beforeCheckoutCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckout.afterCheckoutCounter, 1)

	mmCheckout.t.Helper()

	if mmCheckout.inspectFuncCheckout != nil {
		mmCheckout.inspectFuncCheckout(ctx, o1)
	}

	mm_params := ILOMSServiceMockCheckoutParams{ctx, o1}

	// Record call args
	mmCheckout.CheckoutMock.mutex.Lock()
	mmCheckout.CheckoutMock.callArgs = append(mmCheckout.CheckoutMock.callArgs, &mm_params)
	mmCheckout.CheckoutMock.mutex.Unlock()

	for _, e := range mmCheckout.CheckoutMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o2, e.results.err
		}
	}

	if mmCheckout.CheckoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckout.CheckoutMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckout.CheckoutMock.defaultExpectation.params
		mm_want_ptrs := mmCheckout.CheckoutMock.defaultExpectation.paramPtrs

		mm_got := ILOMSServiceMockCheckoutParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckout.t.Errorf("ILOMSServiceMock.Checkout got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckout.CheckoutMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmCheckout.t.Errorf("ILOMSServiceMock.Checkout got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckout.CheckoutMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckout.t.Errorf("ILOMSServiceMock.Checkout got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckout.CheckoutMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckout.CheckoutMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckout.t.Fatal("No results are set for the ILOMSServiceMock.Checkout")
		}
		return (*mm_results).o2, (*mm_results).err
	}
	if mmCheckout.funcCheckout != nil {
		return mmCheckout.funcCheckout(ctx, o1)
	}
	mmCheckout.t.Fatalf("Unexpected call to ILOMSServiceMock.Checkout. %v %v", ctx, o1)
	return
}

// CheckoutAfterCounter returns a count of finished ILOMSServiceMock.Checkout invocations
func (mmCheckout *ILOMSServiceMock) CheckoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckout.afterCheckoutCounter)
}

// CheckoutBeforeCounter returns a count of ILOMSServiceMock.Checkout invocations
func (mmCheckout *ILOMSServiceMock) CheckoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckout.beforeCheckoutCounter)
}

// Calls returns a list of arguments used in each call to ILOMSServiceMock.Checkout.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckout *mILOMSServiceMockCheckout) Calls() []*ILOMSServiceMockCheckoutParams {
	mmCheckout.mutex.RLock()

	argCopy := make([]*ILOMSServiceMockCheckoutParams, len(mmCheckout.callArgs))
	copy(argCopy, mmCheckout.callArgs)

	mmCheckout.mutex.RUnlock()

	return argCopy
}

// MinimockCheckoutDone returns true if the count of the Checkout invocations corresponds
// the number of defined expectations
func (m *ILOMSServiceMock) MinimockCheckoutDone() bool {
	if m.CheckoutMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckoutMock.invocationsDone()
}

// MinimockCheckoutInspect logs each unmet expectation
func (m *ILOMSServiceMock) MinimockCheckoutInspect() {
	for _, e := range m.CheckoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ILOMSServiceMock.Checkout at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckoutCounter := mm_atomic.LoadUint64(&m.afterCheckoutCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckoutMock.defaultExpectation != nil && afterCheckoutCounter < 1 {
		if m.CheckoutMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ILOMSServiceMock.Checkout at\n%s", m.CheckoutMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ILOMSServiceMock.Checkout at\n%s with params: %#v", m.CheckoutMock.defaultExpectation.expectationOrigins.origin, *m.CheckoutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckout != nil && afterCheckoutCounter < 1 {
		m.t.Errorf("Expected call to ILOMSServiceMock.Checkout at\n%s", m.funcCheckoutOrigin)
	}

	if !m.CheckoutMock.invocationsDone() && afterCheckoutCounter > 0 {
		m.t.Errorf("Expected %d calls to ILOMSServiceMock.Checkout at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckoutMock.expectedInvocations), m.CheckoutMock.expectedInvocationsOrigin, afterCheckoutCounter)
	}
}

type mILOMSServiceMockStocksInfo struct {
	optional           bool
	mock               *ILOMSServiceMock
	defaultExpectation *ILOMSServiceMockStocksInfoExpectation
	expectations       []*ILOMSServiceMockStocksInfoExpectation

	callArgs []*ILOMSServiceMockStocksInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ILOMSServiceMockStocksInfoExpectation specifies expectation struct of the ILOMSService.StocksInfo
type ILOMSServiceMockStocksInfoExpectation struct {
	mock               *ILOMSServiceMock
	params             *ILOMSServiceMockStocksInfoParams
	paramPtrs          *ILOMSServiceMockStocksInfoParamPtrs
	expectationOrigins ILOMSServiceMockStocksInfoExpectationOrigins
	results            *ILOMSServiceMockStocksInfoResults
	returnOrigin       string
	Counter            uint64
}

// ILOMSServiceMockStocksInfoParams contains parameters of the ILOMSService.StocksInfo
type ILOMSServiceMockStocksInfoParams struct {
	ctx context.Context
	s1  domain.Sku
}

// ILOMSServiceMockStocksInfoParamPtrs contains pointers to parameters of the ILOMSService.StocksInfo
type ILOMSServiceMockStocksInfoParamPtrs struct {
	ctx *context.Context
	s1  *domain.Sku
}

// ILOMSServiceMockStocksInfoResults contains results of the ILOMSService.StocksInfo
type ILOMSServiceMockStocksInfoResults struct {
	u1  uint64
	err error
}

// ILOMSServiceMockStocksInfoOrigins contains origins of expectations of the ILOMSService.StocksInfo
type ILOMSServiceMockStocksInfoExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStocksInfo *mILOMSServiceMockStocksInfo) Optional() *mILOMSServiceMockStocksInfo {
	mmStocksInfo.optional = true
	return mmStocksInfo
}

// Expect sets up expected params for ILOMSService.StocksInfo
func (mmStocksInfo *mILOMSServiceMockStocksInfo) Expect(ctx context.Context, s1 domain.Sku) *mILOMSServiceMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("ILOMSServiceMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &ILOMSServiceMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.paramPtrs != nil {
		mmStocksInfo.mock.t.Fatalf("ILOMSServiceMock.StocksInfo mock is already set by ExpectParams functions")
	}

	mmStocksInfo.defaultExpectation.params = &ILOMSServiceMockStocksInfoParams{ctx, s1}
	mmStocksInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStocksInfo.expectations {
		if minimock.Equal(e.params, mmStocksInfo.defaultExpectation.params) {
			mmStocksInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocksInfo.defaultExpectation.params)
		}
	}

	return mmStocksInfo
}

// ExpectCtxParam1 sets up expected param ctx for ILOMSService.StocksInfo
func (mmStocksInfo *mILOMSServiceMockStocksInfo) ExpectCtxParam1(ctx context.Context) *mILOMSServiceMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("ILOMSServiceMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &ILOMSServiceMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.params != nil {
		mmStocksInfo.mock.t.Fatalf("ILOMSServiceMock.StocksInfo mock is already set by Expect")
	}

	if mmStocksInfo.defaultExpectation.paramPtrs == nil {
		mmStocksInfo.defaultExpectation.paramPtrs = &ILOMSServiceMockStocksInfoParamPtrs{}
	}
	mmStocksInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmStocksInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStocksInfo
}

// ExpectS1Param2 sets up expected param s1 for ILOMSService.StocksInfo
func (mmStocksInfo *mILOMSServiceMockStocksInfo) ExpectS1Param2(s1 domain.Sku) *mILOMSServiceMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("ILOMSServiceMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &ILOMSServiceMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.params != nil {
		mmStocksInfo.mock.t.Fatalf("ILOMSServiceMock.StocksInfo mock is already set by Expect")
	}

	if mmStocksInfo.defaultExpectation.paramPtrs == nil {
		mmStocksInfo.defaultExpectation.paramPtrs = &ILOMSServiceMockStocksInfoParamPtrs{}
	}
	mmStocksInfo.defaultExpectation.paramPtrs.s1 = &s1
	mmStocksInfo.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmStocksInfo
}

// Inspect accepts an inspector function that has same arguments as the ILOMSService.StocksInfo
func (mmStocksInfo *mILOMSServiceMockStocksInfo) Inspect(f func(ctx context.Context, s1 domain.Sku)) *mILOMSServiceMockStocksInfo {
	if mmStocksInfo.mock.inspectFuncStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("Inspect function is already set for ILOMSServiceMock.StocksInfo")
	}

	mmStocksInfo.mock.inspectFuncStocksInfo = f

	return mmStocksInfo
}

// Return sets up results that will be returned by ILOMSService.StocksInfo
func (mmStocksInfo *mILOMSServiceMockStocksInfo) Return(u1 uint64, err error) *ILOMSServiceMock {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("ILOMSServiceMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &ILOMSServiceMockStocksInfoExpectation{mock: mmStocksInfo.mock}
	}
	mmStocksInfo.defaultExpectation.results = &ILOMSServiceMockStocksInfoResults{u1, err}
	mmStocksInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStocksInfo.mock
}

// Set uses given function f to mock the ILOMSService.StocksInfo method
func (mmStocksInfo *mILOMSServiceMockStocksInfo) Set(f func(ctx context.Context, s1 domain.Sku) (u1 uint64, err error)) *ILOMSServiceMock {
	if mmStocksInfo.defaultExpectation != nil {
		mmStocksInfo.mock.t.Fatalf("Default expectation is already set for the ILOMSService.StocksInfo method")
	}

	if len(mmStocksInfo.expectations) > 0 {
		mmStocksInfo.mock.t.Fatalf("Some expectations are already set for the ILOMSService.StocksInfo method")
	}

	mmStocksInfo.mock.funcStocksInfo = f
	mmStocksInfo.mock.funcStocksInfoOrigin = minimock.CallerInfo(1)
	return mmStocksInfo.mock
}

// When sets expectation for the ILOMSService.StocksInfo which will trigger the result defined by the following
// Then helper
func (mmStocksInfo *mILOMSServiceMockStocksInfo) When(ctx context.Context, s1 domain.Sku) *ILOMSServiceMockStocksInfoExpectation {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("ILOMSServiceMock.StocksInfo mock is already set by Set")
	}

	expectation := &ILOMSServiceMockStocksInfoExpectation{
		mock:               mmStocksInfo.mock,
		params:             &ILOMSServiceMockStocksInfoParams{ctx, s1},
		expectationOrigins: ILOMSServiceMockStocksInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStocksInfo.expectations = append(mmStocksInfo.expectations, expectation)
	return expectation
}

// Then sets up ILOMSService.StocksInfo return parameters for the expectation previously defined by the When method
func (e *ILOMSServiceMockStocksInfoExpectation) Then(u1 uint64, err error) *ILOMSServiceMock {
	e.results = &ILOMSServiceMockStocksInfoResults{u1, err}
	return e.mock
}

// Times sets number of times ILOMSService.StocksInfo should be invoked
func (mmStocksInfo *mILOMSServiceMockStocksInfo) Times(n uint64) *mILOMSServiceMockStocksInfo {
	if n == 0 {
		mmStocksInfo.mock.t.Fatalf("Times of ILOMSServiceMock.StocksInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStocksInfo.expectedInvocations, n)
	mmStocksInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStocksInfo
}

func (mmStocksInfo *mILOMSServiceMockStocksInfo) invocationsDone() bool {
	if len(mmStocksInfo.expectations) == 0 && mmStocksInfo.defaultExpectation == nil && mmStocksInfo.mock.funcStocksInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStocksInfo.mock.afterStocksInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStocksInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StocksInfo implements mm_service.ILOMSService
func (mmStocksInfo *ILOMSServiceMock) StocksInfo(ctx context.Context, s1 domain.Sku) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmStocksInfo.beforeStocksInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmStocksInfo.afterStocksInfoCounter, 1)

	mmStocksInfo.t.Helper()

	if mmStocksInfo.inspectFuncStocksInfo != nil {
		mmStocksInfo.inspectFuncStocksInfo(ctx, s1)
	}

	mm_params := ILOMSServiceMockStocksInfoParams{ctx, s1}

	// Record call args
	mmStocksInfo.StocksInfoMock.mutex.Lock()
	mmStocksInfo.StocksInfoMock.callArgs = append(mmStocksInfo.StocksInfoMock.callArgs, &mm_params)
	mmStocksInfo.StocksInfoMock.mutex.Unlock()

	for _, e := range mmStocksInfo.StocksInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmStocksInfo.StocksInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocksInfo.StocksInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmStocksInfo.StocksInfoMock.defaultExpectation.params
		mm_want_ptrs := mmStocksInfo.StocksInfoMock.defaultExpectation.paramPtrs

		mm_got := ILOMSServiceMockStocksInfoParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStocksInfo.t.Errorf("ILOMSServiceMock.StocksInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStocksInfo.StocksInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmStocksInfo.t.Errorf("ILOMSServiceMock.StocksInfo got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStocksInfo.StocksInfoMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocksInfo.t.Errorf("ILOMSServiceMock.StocksInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStocksInfo.StocksInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocksInfo.StocksInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmStocksInfo.t.Fatal("No results are set for the ILOMSServiceMock.StocksInfo")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmStocksInfo.funcStocksInfo != nil {
		return mmStocksInfo.funcStocksInfo(ctx, s1)
	}
	mmStocksInfo.t.Fatalf("Unexpected call to ILOMSServiceMock.StocksInfo. %v %v", ctx, s1)
	return
}

// StocksInfoAfterCounter returns a count of finished ILOMSServiceMock.StocksInfo invocations
func (mmStocksInfo *ILOMSServiceMock) StocksInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksInfo.afterStocksInfoCounter)
}

// StocksInfoBeforeCounter returns a count of ILOMSServiceMock.StocksInfo invocations
func (mmStocksInfo *ILOMSServiceMock) StocksInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksInfo.beforeStocksInfoCounter)
}

// Calls returns a list of arguments used in each call to ILOMSServiceMock.StocksInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocksInfo *mILOMSServiceMockStocksInfo) Calls() []*ILOMSServiceMockStocksInfoParams {
	mmStocksInfo.mutex.RLock()

	argCopy := make([]*ILOMSServiceMockStocksInfoParams, len(mmStocksInfo.callArgs))
	copy(argCopy, mmStocksInfo.callArgs)

	mmStocksInfo.mutex.RUnlock()

	return argCopy
}

// MinimockStocksInfoDone returns true if the count of the StocksInfo invocations corresponds
// the number of defined expectations
func (m *ILOMSServiceMock) MinimockStocksInfoDone() bool {
	if m.StocksInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StocksInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StocksInfoMock.invocationsDone()
}

// MinimockStocksInfoInspect logs each unmet expectation
func (m *ILOMSServiceMock) MinimockStocksInfoInspect() {
	for _, e := range m.StocksInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ILOMSServiceMock.StocksInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStocksInfoCounter := mm_atomic.LoadUint64(&m.afterStocksInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StocksInfoMock.defaultExpectation != nil && afterStocksInfoCounter < 1 {
		if m.StocksInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ILOMSServiceMock.StocksInfo at\n%s", m.StocksInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ILOMSServiceMock.StocksInfo at\n%s with params: %#v", m.StocksInfoMock.defaultExpectation.expectationOrigins.origin, *m.StocksInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocksInfo != nil && afterStocksInfoCounter < 1 {
		m.t.Errorf("Expected call to ILOMSServiceMock.StocksInfo at\n%s", m.funcStocksInfoOrigin)
	}

	if !m.StocksInfoMock.invocationsDone() && afterStocksInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to ILOMSServiceMock.StocksInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StocksInfoMock.expectedInvocations), m.StocksInfoMock.expectedInvocationsOrigin, afterStocksInfoCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ILOMSServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckoutInspect()

			m.MinimockStocksInfoInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ILOMSServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ILOMSServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckoutDone() &&
		m.MinimockStocksInfoDone()
}
