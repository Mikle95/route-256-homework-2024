// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/1mikle1/homework/cart/internal/pkg/cart/service.CartRepository -o cart_repository_mock_test.go -n CartRepositoryMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/1mikle1/homework/cart/internal/pkg/cart/model"
)

// CartRepositoryMock implements mm_service.CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, item model.CartItem) (c2 model.CartItem, err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, item model.CartItem)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mCartRepositoryMockAddItem

	funcDeleteCart          func(ctx context.Context, userId model.UID) (err error)
	funcDeleteCartOrigin    string
	inspectFuncDeleteCart   func(ctx context.Context, userId model.UID)
	afterDeleteCartCounter  uint64
	beforeDeleteCartCounter uint64
	DeleteCartMock          mCartRepositoryMockDeleteCart

	funcDeleteItem          func(ctx context.Context, userId model.UID, sku model.Sku) (err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, userId model.UID, sku model.Sku)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mCartRepositoryMockDeleteItem

	funcGetItems          func(ctx context.Context, userId model.UID) (ca1 []model.CartItem, err error)
	funcGetItemsOrigin    string
	inspectFuncGetItems   func(ctx context.Context, userId model.UID)
	afterGetItemsCounter  uint64
	beforeGetItemsCounter uint64
	GetItemsMock          mCartRepositoryMockGetItems
}

// NewCartRepositoryMock returns a mock for mm_service.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mCartRepositoryMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*CartRepositoryMockAddItemParams{}

	m.DeleteCartMock = mCartRepositoryMockDeleteCart{mock: m}
	m.DeleteCartMock.callArgs = []*CartRepositoryMockDeleteCartParams{}

	m.DeleteItemMock = mCartRepositoryMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*CartRepositoryMockDeleteItemParams{}

	m.GetItemsMock = mCartRepositoryMockGetItems{mock: m}
	m.GetItemsMock.callArgs = []*CartRepositoryMockGetItemsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockAddItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddItemExpectation
	expectations       []*CartRepositoryMockAddItemExpectation

	callArgs []*CartRepositoryMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockAddItemExpectation specifies expectation struct of the CartRepository.AddItem
type CartRepositoryMockAddItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockAddItemParams
	paramPtrs          *CartRepositoryMockAddItemParamPtrs
	expectationOrigins CartRepositoryMockAddItemExpectationOrigins
	results            *CartRepositoryMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockAddItemParams contains parameters of the CartRepository.AddItem
type CartRepositoryMockAddItemParams struct {
	ctx  context.Context
	item model.CartItem
}

// CartRepositoryMockAddItemParamPtrs contains pointers to parameters of the CartRepository.AddItem
type CartRepositoryMockAddItemParamPtrs struct {
	ctx  *context.Context
	item *model.CartItem
}

// CartRepositoryMockAddItemResults contains results of the CartRepository.AddItem
type CartRepositoryMockAddItemResults struct {
	c2  model.CartItem
	err error
}

// CartRepositoryMockAddItemOrigins contains origins of expectations of the CartRepository.AddItem
type CartRepositoryMockAddItemExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mCartRepositoryMockAddItem) Optional() *mCartRepositoryMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Expect(ctx context.Context, item model.CartItem) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &CartRepositoryMockAddItemParams{ctx, item}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectItemParam2 sets up expected param item for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) ExpectItemParam2(item model.CartItem) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.item = &item
	mmAddItem.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Inspect(f func(ctx context.Context, item model.CartItem)) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Return(c2 model.CartItem, err error) *CartRepositoryMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &CartRepositoryMockAddItemResults{c2, err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the CartRepository.AddItem method
func (mmAddItem *mCartRepositoryMockAddItem) Set(f func(ctx context.Context, item model.CartItem) (c2 model.CartItem, err error)) *CartRepositoryMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the CartRepository.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mCartRepositoryMockAddItem) When(ctx context.Context, item model.CartItem) *CartRepositoryMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &CartRepositoryMockAddItemParams{ctx, item},
		expectationOrigins: CartRepositoryMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.AddItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddItemExpectation) Then(c2 model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddItemResults{c2, err}
	return e.mock
}

// Times sets number of times CartRepository.AddItem should be invoked
func (mmAddItem *mCartRepositoryMockAddItem) Times(n uint64) *mCartRepositoryMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of CartRepositoryMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mCartRepositoryMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_service.CartRepository
func (mmAddItem *CartRepositoryMock) AddItem(ctx context.Context, item model.CartItem) (c2 model.CartItem, err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, item)
	}

	mm_params := CartRepositoryMockAddItemParams{ctx, item}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockAddItemParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the CartRepositoryMock.AddItem")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, item)
	}
	mmAddItem.t.Fatalf("Unexpected call to CartRepositoryMock.AddItem. %v %v", ctx, item)
	return
}

// AddItemAfterCounter returns a count of finished CartRepositoryMock.AddItem invocations
func (mmAddItem *CartRepositoryMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of CartRepositoryMock.AddItem invocations
func (mmAddItem *CartRepositoryMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mCartRepositoryMockAddItem) Calls() []*CartRepositoryMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mCartRepositoryMockDeleteCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteCartExpectation
	expectations       []*CartRepositoryMockDeleteCartExpectation

	callArgs []*CartRepositoryMockDeleteCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteCartExpectation specifies expectation struct of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteCartParams
	paramPtrs          *CartRepositoryMockDeleteCartParamPtrs
	expectationOrigins CartRepositoryMockDeleteCartExpectationOrigins
	results            *CartRepositoryMockDeleteCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDeleteCartParams contains parameters of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartParams struct {
	ctx    context.Context
	userId model.UID
}

// CartRepositoryMockDeleteCartParamPtrs contains pointers to parameters of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartParamPtrs struct {
	ctx    *context.Context
	userId *model.UID
}

// CartRepositoryMockDeleteCartResults contains results of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartResults struct {
	err error
}

// CartRepositoryMockDeleteCartOrigins contains origins of expectations of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Optional() *mCartRepositoryMockDeleteCart {
	mmDeleteCart.optional = true
	return mmDeleteCart
}

// Expect sets up expected params for CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Expect(ctx context.Context, userId model.UID) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.paramPtrs != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by ExpectParams functions")
	}

	mmDeleteCart.defaultExpectation.params = &CartRepositoryMockDeleteCartParams{ctx, userId}
	mmDeleteCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCart.expectations {
		if minimock.Equal(e.params, mmDeleteCart.defaultExpectation.params) {
			mmDeleteCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCart.defaultExpectation.params)
		}
	}

	return mmDeleteCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.params != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Expect")
	}

	if mmDeleteCart.defaultExpectation.paramPtrs == nil {
		mmDeleteCart.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteCartParamPtrs{}
	}
	mmDeleteCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCart
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) ExpectUserIdParam2(userId model.UID) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.params != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Expect")
	}

	if mmDeleteCart.defaultExpectation.paramPtrs == nil {
		mmDeleteCart.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteCartParamPtrs{}
	}
	mmDeleteCart.defaultExpectation.paramPtrs.userId = &userId
	mmDeleteCart.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmDeleteCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Inspect(f func(ctx context.Context, userId model.UID)) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.inspectFuncDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteCart")
	}

	mmDeleteCart.mock.inspectFuncDeleteCart = f

	return mmDeleteCart
}

// Return sets up results that will be returned by CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Return(err error) *CartRepositoryMock {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{mock: mmDeleteCart.mock}
	}
	mmDeleteCart.defaultExpectation.results = &CartRepositoryMockDeleteCartResults{err}
	mmDeleteCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCart.mock
}

// Set uses given function f to mock the CartRepository.DeleteCart method
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Set(f func(ctx context.Context, userId model.UID) (err error)) *CartRepositoryMock {
	if mmDeleteCart.defaultExpectation != nil {
		mmDeleteCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteCart method")
	}

	if len(mmDeleteCart.expectations) > 0 {
		mmDeleteCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteCart method")
	}

	mmDeleteCart.mock.funcDeleteCart = f
	mmDeleteCart.mock.funcDeleteCartOrigin = minimock.CallerInfo(1)
	return mmDeleteCart.mock
}

// When sets expectation for the CartRepository.DeleteCart which will trigger the result defined by the following
// Then helper
func (mmDeleteCart *mCartRepositoryMockDeleteCart) When(ctx context.Context, userId model.UID) *CartRepositoryMockDeleteCartExpectation {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteCartExpectation{
		mock:               mmDeleteCart.mock,
		params:             &CartRepositoryMockDeleteCartParams{ctx, userId},
		expectationOrigins: CartRepositoryMockDeleteCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCart.expectations = append(mmDeleteCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteCart should be invoked
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Times(n uint64) *mCartRepositoryMockDeleteCart {
	if n == 0 {
		mmDeleteCart.mock.t.Fatalf("Times of CartRepositoryMock.DeleteCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCart.expectedInvocations, n)
	mmDeleteCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCart
}

func (mmDeleteCart *mCartRepositoryMockDeleteCart) invocationsDone() bool {
	if len(mmDeleteCart.expectations) == 0 && mmDeleteCart.defaultExpectation == nil && mmDeleteCart.mock.funcDeleteCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCart.mock.afterDeleteCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCart implements mm_service.CartRepository
func (mmDeleteCart *CartRepositoryMock) DeleteCart(ctx context.Context, userId model.UID) (err error) {
	mm_atomic.AddUint64(&mmDeleteCart.beforeDeleteCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCart.afterDeleteCartCounter, 1)

	mmDeleteCart.t.Helper()

	if mmDeleteCart.inspectFuncDeleteCart != nil {
		mmDeleteCart.inspectFuncDeleteCart(ctx, userId)
	}

	mm_params := CartRepositoryMockDeleteCartParams{ctx, userId}

	// Record call args
	mmDeleteCart.DeleteCartMock.mutex.Lock()
	mmDeleteCart.DeleteCartMock.callArgs = append(mmDeleteCart.DeleteCartMock.callArgs, &mm_params)
	mmDeleteCart.DeleteCartMock.mutex.Unlock()

	for _, e := range mmDeleteCart.DeleteCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCart.DeleteCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCart.DeleteCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCart.DeleteCartMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCart.DeleteCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteCartParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCart.t.Errorf("CartRepositoryMock.DeleteCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmDeleteCart.t.Errorf("CartRepositoryMock.DeleteCart got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCart.t.Errorf("CartRepositoryMock.DeleteCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCart.DeleteCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCart.t.Fatal("No results are set for the CartRepositoryMock.DeleteCart")
		}
		return (*mm_results).err
	}
	if mmDeleteCart.funcDeleteCart != nil {
		return mmDeleteCart.funcDeleteCart(ctx, userId)
	}
	mmDeleteCart.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteCart. %v %v", ctx, userId)
	return
}

// DeleteCartAfterCounter returns a count of finished CartRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CartRepositoryMock) DeleteCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.afterDeleteCartCounter)
}

// DeleteCartBeforeCounter returns a count of CartRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CartRepositoryMock) DeleteCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.beforeDeleteCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Calls() []*CartRepositoryMockDeleteCartParams {
	mmDeleteCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteCartParams, len(mmDeleteCart.callArgs))
	copy(argCopy, mmDeleteCart.callArgs)

	mmDeleteCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartDone returns true if the count of the DeleteCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteCartDone() bool {
	if m.DeleteCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCartMock.invocationsDone()
}

// MinimockDeleteCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteCartInspect() {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCartCounter := mm_atomic.LoadUint64(&m.afterDeleteCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && afterDeleteCartCounter < 1 {
		if m.DeleteCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s", m.DeleteCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s with params: %#v", m.DeleteCartMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && afterDeleteCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s", m.funcDeleteCartOrigin)
	}

	if !m.DeleteCartMock.invocationsDone() && afterDeleteCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCartMock.expectedInvocations), m.DeleteCartMock.expectedInvocationsOrigin, afterDeleteCartCounter)
	}
}

type mCartRepositoryMockDeleteItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteItemExpectation
	expectations       []*CartRepositoryMockDeleteItemExpectation

	callArgs []*CartRepositoryMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteItemExpectation specifies expectation struct of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteItemParams
	paramPtrs          *CartRepositoryMockDeleteItemParamPtrs
	expectationOrigins CartRepositoryMockDeleteItemExpectationOrigins
	results            *CartRepositoryMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDeleteItemParams contains parameters of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemParams struct {
	ctx    context.Context
	userId model.UID
	sku    model.Sku
}

// CartRepositoryMockDeleteItemParamPtrs contains pointers to parameters of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemParamPtrs struct {
	ctx    *context.Context
	userId *model.UID
	sku    *model.Sku
}

// CartRepositoryMockDeleteItemResults contains results of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemResults struct {
	err error
}

// CartRepositoryMockDeleteItemOrigins contains origins of expectations of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
	originSku    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Optional() *mCartRepositoryMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Expect(ctx context.Context, userId model.UID, sku model.Sku) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &CartRepositoryMockDeleteItemParams{ctx, userId, sku}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) ExpectUserIdParam2(userId model.UID) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.userId = &userId
	mmDeleteItem.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectSkuParam3 sets up expected param sku for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) ExpectSkuParam3(sku model.Sku) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.sku = &sku
	mmDeleteItem.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Inspect(f func(ctx context.Context, userId model.UID, sku model.Sku)) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Return(err error) *CartRepositoryMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &CartRepositoryMockDeleteItemResults{err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the CartRepository.DeleteItem method
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Set(f func(ctx context.Context, userId model.UID, sku model.Sku) (err error)) *CartRepositoryMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the CartRepository.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mCartRepositoryMockDeleteItem) When(ctx context.Context, userId model.UID, sku model.Sku) *CartRepositoryMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &CartRepositoryMockDeleteItemParams{ctx, userId, sku},
		expectationOrigins: CartRepositoryMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteItemExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteItem should be invoked
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Times(n uint64) *mCartRepositoryMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of CartRepositoryMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mCartRepositoryMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_service.CartRepository
func (mmDeleteItem *CartRepositoryMock) DeleteItem(ctx context.Context, userId model.UID, sku model.Sku) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userId, sku)
	}

	mm_params := CartRepositoryMockDeleteItemParams{ctx, userId, sku}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteItemParams{ctx, userId, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the CartRepositoryMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userId, sku)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteItem. %v %v %v", ctx, userId, sku)
	return
}

// DeleteItemAfterCounter returns a count of finished CartRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CartRepositoryMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of CartRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CartRepositoryMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Calls() []*CartRepositoryMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mCartRepositoryMockGetItems struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetItemsExpectation
	expectations       []*CartRepositoryMockGetItemsExpectation

	callArgs []*CartRepositoryMockGetItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetItemsExpectation specifies expectation struct of the CartRepository.GetItems
type CartRepositoryMockGetItemsExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetItemsParams
	paramPtrs          *CartRepositoryMockGetItemsParamPtrs
	expectationOrigins CartRepositoryMockGetItemsExpectationOrigins
	results            *CartRepositoryMockGetItemsResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetItemsParams contains parameters of the CartRepository.GetItems
type CartRepositoryMockGetItemsParams struct {
	ctx    context.Context
	userId model.UID
}

// CartRepositoryMockGetItemsParamPtrs contains pointers to parameters of the CartRepository.GetItems
type CartRepositoryMockGetItemsParamPtrs struct {
	ctx    *context.Context
	userId *model.UID
}

// CartRepositoryMockGetItemsResults contains results of the CartRepository.GetItems
type CartRepositoryMockGetItemsResults struct {
	ca1 []model.CartItem
	err error
}

// CartRepositoryMockGetItemsOrigins contains origins of expectations of the CartRepository.GetItems
type CartRepositoryMockGetItemsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItems *mCartRepositoryMockGetItems) Optional() *mCartRepositoryMockGetItems {
	mmGetItems.optional = true
	return mmGetItems
}

// Expect sets up expected params for CartRepository.GetItems
func (mmGetItems *mCartRepositoryMockGetItems) Expect(ctx context.Context, userId model.UID) *mCartRepositoryMockGetItems {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("CartRepositoryMock.GetItems mock is already set by Set")
	}

	if mmGetItems.defaultExpectation == nil {
		mmGetItems.defaultExpectation = &CartRepositoryMockGetItemsExpectation{}
	}

	if mmGetItems.defaultExpectation.paramPtrs != nil {
		mmGetItems.mock.t.Fatalf("CartRepositoryMock.GetItems mock is already set by ExpectParams functions")
	}

	mmGetItems.defaultExpectation.params = &CartRepositoryMockGetItemsParams{ctx, userId}
	mmGetItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItems.expectations {
		if minimock.Equal(e.params, mmGetItems.defaultExpectation.params) {
			mmGetItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItems.defaultExpectation.params)
		}
	}

	return mmGetItems
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.GetItems
func (mmGetItems *mCartRepositoryMockGetItems) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetItems {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("CartRepositoryMock.GetItems mock is already set by Set")
	}

	if mmGetItems.defaultExpectation == nil {
		mmGetItems.defaultExpectation = &CartRepositoryMockGetItemsExpectation{}
	}

	if mmGetItems.defaultExpectation.params != nil {
		mmGetItems.mock.t.Fatalf("CartRepositoryMock.GetItems mock is already set by Expect")
	}

	if mmGetItems.defaultExpectation.paramPtrs == nil {
		mmGetItems.defaultExpectation.paramPtrs = &CartRepositoryMockGetItemsParamPtrs{}
	}
	mmGetItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItems
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.GetItems
func (mmGetItems *mCartRepositoryMockGetItems) ExpectUserIdParam2(userId model.UID) *mCartRepositoryMockGetItems {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("CartRepositoryMock.GetItems mock is already set by Set")
	}

	if mmGetItems.defaultExpectation == nil {
		mmGetItems.defaultExpectation = &CartRepositoryMockGetItemsExpectation{}
	}

	if mmGetItems.defaultExpectation.params != nil {
		mmGetItems.mock.t.Fatalf("CartRepositoryMock.GetItems mock is already set by Expect")
	}

	if mmGetItems.defaultExpectation.paramPtrs == nil {
		mmGetItems.defaultExpectation.paramPtrs = &CartRepositoryMockGetItemsParamPtrs{}
	}
	mmGetItems.defaultExpectation.paramPtrs.userId = &userId
	mmGetItems.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmGetItems
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetItems
func (mmGetItems *mCartRepositoryMockGetItems) Inspect(f func(ctx context.Context, userId model.UID)) *mCartRepositoryMockGetItems {
	if mmGetItems.mock.inspectFuncGetItems != nil {
		mmGetItems.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetItems")
	}

	mmGetItems.mock.inspectFuncGetItems = f

	return mmGetItems
}

// Return sets up results that will be returned by CartRepository.GetItems
func (mmGetItems *mCartRepositoryMockGetItems) Return(ca1 []model.CartItem, err error) *CartRepositoryMock {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("CartRepositoryMock.GetItems mock is already set by Set")
	}

	if mmGetItems.defaultExpectation == nil {
		mmGetItems.defaultExpectation = &CartRepositoryMockGetItemsExpectation{mock: mmGetItems.mock}
	}
	mmGetItems.defaultExpectation.results = &CartRepositoryMockGetItemsResults{ca1, err}
	mmGetItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItems.mock
}

// Set uses given function f to mock the CartRepository.GetItems method
func (mmGetItems *mCartRepositoryMockGetItems) Set(f func(ctx context.Context, userId model.UID) (ca1 []model.CartItem, err error)) *CartRepositoryMock {
	if mmGetItems.defaultExpectation != nil {
		mmGetItems.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetItems method")
	}

	if len(mmGetItems.expectations) > 0 {
		mmGetItems.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetItems method")
	}

	mmGetItems.mock.funcGetItems = f
	mmGetItems.mock.funcGetItemsOrigin = minimock.CallerInfo(1)
	return mmGetItems.mock
}

// When sets expectation for the CartRepository.GetItems which will trigger the result defined by the following
// Then helper
func (mmGetItems *mCartRepositoryMockGetItems) When(ctx context.Context, userId model.UID) *CartRepositoryMockGetItemsExpectation {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("CartRepositoryMock.GetItems mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetItemsExpectation{
		mock:               mmGetItems.mock,
		params:             &CartRepositoryMockGetItemsParams{ctx, userId},
		expectationOrigins: CartRepositoryMockGetItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItems.expectations = append(mmGetItems.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetItems return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetItemsExpectation) Then(ca1 []model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetItemsResults{ca1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetItems should be invoked
func (mmGetItems *mCartRepositoryMockGetItems) Times(n uint64) *mCartRepositoryMockGetItems {
	if n == 0 {
		mmGetItems.mock.t.Fatalf("Times of CartRepositoryMock.GetItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItems.expectedInvocations, n)
	mmGetItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItems
}

func (mmGetItems *mCartRepositoryMockGetItems) invocationsDone() bool {
	if len(mmGetItems.expectations) == 0 && mmGetItems.defaultExpectation == nil && mmGetItems.mock.funcGetItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItems.mock.afterGetItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItems implements mm_service.CartRepository
func (mmGetItems *CartRepositoryMock) GetItems(ctx context.Context, userId model.UID) (ca1 []model.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetItems.beforeGetItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItems.afterGetItemsCounter, 1)

	mmGetItems.t.Helper()

	if mmGetItems.inspectFuncGetItems != nil {
		mmGetItems.inspectFuncGetItems(ctx, userId)
	}

	mm_params := CartRepositoryMockGetItemsParams{ctx, userId}

	// Record call args
	mmGetItems.GetItemsMock.mutex.Lock()
	mmGetItems.GetItemsMock.callArgs = append(mmGetItems.GetItemsMock.callArgs, &mm_params)
	mmGetItems.GetItemsMock.mutex.Unlock()

	for _, e := range mmGetItems.GetItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetItems.GetItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItems.GetItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItems.GetItemsMock.defaultExpectation.params
		mm_want_ptrs := mmGetItems.GetItemsMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetItemsParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItems.t.Errorf("CartRepositoryMock.GetItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItems.GetItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmGetItems.t.Errorf("CartRepositoryMock.GetItems got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItems.GetItemsMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItems.t.Errorf("CartRepositoryMock.GetItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItems.GetItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItems.GetItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItems.t.Fatal("No results are set for the CartRepositoryMock.GetItems")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetItems.funcGetItems != nil {
		return mmGetItems.funcGetItems(ctx, userId)
	}
	mmGetItems.t.Fatalf("Unexpected call to CartRepositoryMock.GetItems. %v %v", ctx, userId)
	return
}

// GetItemsAfterCounter returns a count of finished CartRepositoryMock.GetItems invocations
func (mmGetItems *CartRepositoryMock) GetItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItems.afterGetItemsCounter)
}

// GetItemsBeforeCounter returns a count of CartRepositoryMock.GetItems invocations
func (mmGetItems *CartRepositoryMock) GetItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItems.beforeGetItemsCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItems *mCartRepositoryMockGetItems) Calls() []*CartRepositoryMockGetItemsParams {
	mmGetItems.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetItemsParams, len(mmGetItems.callArgs))
	copy(argCopy, mmGetItems.callArgs)

	mmGetItems.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsDone returns true if the count of the GetItems invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetItemsDone() bool {
	if m.GetItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsMock.invocationsDone()
}

// MinimockGetItemsInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetItemsInspect() {
	for _, e := range m.GetItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemsCounter := mm_atomic.LoadUint64(&m.afterGetItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsMock.defaultExpectation != nil && afterGetItemsCounter < 1 {
		if m.GetItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItems at\n%s", m.GetItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItems at\n%s with params: %#v", m.GetItemsMock.defaultExpectation.expectationOrigins.origin, *m.GetItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItems != nil && afterGetItemsCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetItems at\n%s", m.funcGetItemsOrigin)
	}

	if !m.GetItemsMock.invocationsDone() && afterGetItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsMock.expectedInvocations), m.GetItemsMock.expectedInvocationsOrigin, afterGetItemsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteCartInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockGetItemsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteCartDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockGetItemsDone()
}
