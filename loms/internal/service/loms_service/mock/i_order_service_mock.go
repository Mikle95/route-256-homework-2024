// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/1mikle1/homework/loms/internal/service/loms_service.IOrderService -o i_order_service_mock_test.go -n IOrderServiceMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/1mikle1/homework/loms/internal/model"
)

// IOrderServiceMock implements mm_loms_service.IOrderService
type IOrderServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, o1 model.Order) (o2 model.OID, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, o1 model.Order)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mIOrderServiceMockCreate

	funcGetById          func(ctx context.Context, o1 model.OID) (o2 model.Order, err error)
	funcGetByIdOrigin    string
	inspectFuncGetById   func(ctx context.Context, o1 model.OID)
	afterGetByIdCounter  uint64
	beforeGetByIdCounter uint64
	GetByIdMock          mIOrderServiceMockGetById

	funcSetStatus          func(ctx context.Context, o1 model.OID, s1 string) (err error)
	funcSetStatusOrigin    string
	inspectFuncSetStatus   func(ctx context.Context, o1 model.OID, s1 string)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mIOrderServiceMockSetStatus
}

// NewIOrderServiceMock returns a mock for mm_loms_service.IOrderService
func NewIOrderServiceMock(t minimock.Tester) *IOrderServiceMock {
	m := &IOrderServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mIOrderServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*IOrderServiceMockCreateParams{}

	m.GetByIdMock = mIOrderServiceMockGetById{mock: m}
	m.GetByIdMock.callArgs = []*IOrderServiceMockGetByIdParams{}

	m.SetStatusMock = mIOrderServiceMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*IOrderServiceMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIOrderServiceMockCreate struct {
	optional           bool
	mock               *IOrderServiceMock
	defaultExpectation *IOrderServiceMockCreateExpectation
	expectations       []*IOrderServiceMockCreateExpectation

	callArgs []*IOrderServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderServiceMockCreateExpectation specifies expectation struct of the IOrderService.Create
type IOrderServiceMockCreateExpectation struct {
	mock               *IOrderServiceMock
	params             *IOrderServiceMockCreateParams
	paramPtrs          *IOrderServiceMockCreateParamPtrs
	expectationOrigins IOrderServiceMockCreateExpectationOrigins
	results            *IOrderServiceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// IOrderServiceMockCreateParams contains parameters of the IOrderService.Create
type IOrderServiceMockCreateParams struct {
	ctx context.Context
	o1  model.Order
}

// IOrderServiceMockCreateParamPtrs contains pointers to parameters of the IOrderService.Create
type IOrderServiceMockCreateParamPtrs struct {
	ctx *context.Context
	o1  *model.Order
}

// IOrderServiceMockCreateResults contains results of the IOrderService.Create
type IOrderServiceMockCreateResults struct {
	o2  model.OID
	err error
}

// IOrderServiceMockCreateOrigins contains origins of expectations of the IOrderService.Create
type IOrderServiceMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mIOrderServiceMockCreate) Optional() *mIOrderServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for IOrderService.Create
func (mmCreate *mIOrderServiceMockCreate) Expect(ctx context.Context, o1 model.Order) *mIOrderServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IOrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IOrderServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("IOrderServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &IOrderServiceMockCreateParams{ctx, o1}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for IOrderService.Create
func (mmCreate *mIOrderServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mIOrderServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IOrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IOrderServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("IOrderServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &IOrderServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectO1Param2 sets up expected param o1 for IOrderService.Create
func (mmCreate *mIOrderServiceMockCreate) ExpectO1Param2(o1 model.Order) *mIOrderServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IOrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IOrderServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("IOrderServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &IOrderServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.o1 = &o1
	mmCreate.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the IOrderService.Create
func (mmCreate *mIOrderServiceMockCreate) Inspect(f func(ctx context.Context, o1 model.Order)) *mIOrderServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for IOrderServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by IOrderService.Create
func (mmCreate *mIOrderServiceMockCreate) Return(o2 model.OID, err error) *IOrderServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IOrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IOrderServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &IOrderServiceMockCreateResults{o2, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the IOrderService.Create method
func (mmCreate *mIOrderServiceMockCreate) Set(f func(ctx context.Context, o1 model.Order) (o2 model.OID, err error)) *IOrderServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the IOrderService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the IOrderService.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the IOrderService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mIOrderServiceMockCreate) When(ctx context.Context, o1 model.Order) *IOrderServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IOrderServiceMock.Create mock is already set by Set")
	}

	expectation := &IOrderServiceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &IOrderServiceMockCreateParams{ctx, o1},
		expectationOrigins: IOrderServiceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up IOrderService.Create return parameters for the expectation previously defined by the When method
func (e *IOrderServiceMockCreateExpectation) Then(o2 model.OID, err error) *IOrderServiceMock {
	e.results = &IOrderServiceMockCreateResults{o2, err}
	return e.mock
}

// Times sets number of times IOrderService.Create should be invoked
func (mmCreate *mIOrderServiceMockCreate) Times(n uint64) *mIOrderServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of IOrderServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mIOrderServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_loms_service.IOrderService
func (mmCreate *IOrderServiceMock) Create(ctx context.Context, o1 model.Order) (o2 model.OID, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, o1)
	}

	mm_params := IOrderServiceMockCreateParams{ctx, o1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o2, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := IOrderServiceMockCreateParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("IOrderServiceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmCreate.t.Errorf("IOrderServiceMock.Create got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("IOrderServiceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the IOrderServiceMock.Create")
		}
		return (*mm_results).o2, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, o1)
	}
	mmCreate.t.Fatalf("Unexpected call to IOrderServiceMock.Create. %v %v", ctx, o1)
	return
}

// CreateAfterCounter returns a count of finished IOrderServiceMock.Create invocations
func (mmCreate *IOrderServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of IOrderServiceMock.Create invocations
func (mmCreate *IOrderServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to IOrderServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mIOrderServiceMockCreate) Calls() []*IOrderServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*IOrderServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *IOrderServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *IOrderServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderServiceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderServiceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderServiceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to IOrderServiceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderServiceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mIOrderServiceMockGetById struct {
	optional           bool
	mock               *IOrderServiceMock
	defaultExpectation *IOrderServiceMockGetByIdExpectation
	expectations       []*IOrderServiceMockGetByIdExpectation

	callArgs []*IOrderServiceMockGetByIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderServiceMockGetByIdExpectation specifies expectation struct of the IOrderService.GetById
type IOrderServiceMockGetByIdExpectation struct {
	mock               *IOrderServiceMock
	params             *IOrderServiceMockGetByIdParams
	paramPtrs          *IOrderServiceMockGetByIdParamPtrs
	expectationOrigins IOrderServiceMockGetByIdExpectationOrigins
	results            *IOrderServiceMockGetByIdResults
	returnOrigin       string
	Counter            uint64
}

// IOrderServiceMockGetByIdParams contains parameters of the IOrderService.GetById
type IOrderServiceMockGetByIdParams struct {
	ctx context.Context
	o1  model.OID
}

// IOrderServiceMockGetByIdParamPtrs contains pointers to parameters of the IOrderService.GetById
type IOrderServiceMockGetByIdParamPtrs struct {
	ctx *context.Context
	o1  *model.OID
}

// IOrderServiceMockGetByIdResults contains results of the IOrderService.GetById
type IOrderServiceMockGetByIdResults struct {
	o2  model.Order
	err error
}

// IOrderServiceMockGetByIdOrigins contains origins of expectations of the IOrderService.GetById
type IOrderServiceMockGetByIdExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetById *mIOrderServiceMockGetById) Optional() *mIOrderServiceMockGetById {
	mmGetById.optional = true
	return mmGetById
}

// Expect sets up expected params for IOrderService.GetById
func (mmGetById *mIOrderServiceMockGetById) Expect(ctx context.Context, o1 model.OID) *mIOrderServiceMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("IOrderServiceMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &IOrderServiceMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.paramPtrs != nil {
		mmGetById.mock.t.Fatalf("IOrderServiceMock.GetById mock is already set by ExpectParams functions")
	}

	mmGetById.defaultExpectation.params = &IOrderServiceMockGetByIdParams{ctx, o1}
	mmGetById.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetById.expectations {
		if minimock.Equal(e.params, mmGetById.defaultExpectation.params) {
			mmGetById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetById.defaultExpectation.params)
		}
	}

	return mmGetById
}

// ExpectCtxParam1 sets up expected param ctx for IOrderService.GetById
func (mmGetById *mIOrderServiceMockGetById) ExpectCtxParam1(ctx context.Context) *mIOrderServiceMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("IOrderServiceMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &IOrderServiceMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("IOrderServiceMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &IOrderServiceMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetById.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetById
}

// ExpectO1Param2 sets up expected param o1 for IOrderService.GetById
func (mmGetById *mIOrderServiceMockGetById) ExpectO1Param2(o1 model.OID) *mIOrderServiceMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("IOrderServiceMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &IOrderServiceMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("IOrderServiceMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &IOrderServiceMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.o1 = &o1
	mmGetById.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmGetById
}

// Inspect accepts an inspector function that has same arguments as the IOrderService.GetById
func (mmGetById *mIOrderServiceMockGetById) Inspect(f func(ctx context.Context, o1 model.OID)) *mIOrderServiceMockGetById {
	if mmGetById.mock.inspectFuncGetById != nil {
		mmGetById.mock.t.Fatalf("Inspect function is already set for IOrderServiceMock.GetById")
	}

	mmGetById.mock.inspectFuncGetById = f

	return mmGetById
}

// Return sets up results that will be returned by IOrderService.GetById
func (mmGetById *mIOrderServiceMockGetById) Return(o2 model.Order, err error) *IOrderServiceMock {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("IOrderServiceMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &IOrderServiceMockGetByIdExpectation{mock: mmGetById.mock}
	}
	mmGetById.defaultExpectation.results = &IOrderServiceMockGetByIdResults{o2, err}
	mmGetById.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetById.mock
}

// Set uses given function f to mock the IOrderService.GetById method
func (mmGetById *mIOrderServiceMockGetById) Set(f func(ctx context.Context, o1 model.OID) (o2 model.Order, err error)) *IOrderServiceMock {
	if mmGetById.defaultExpectation != nil {
		mmGetById.mock.t.Fatalf("Default expectation is already set for the IOrderService.GetById method")
	}

	if len(mmGetById.expectations) > 0 {
		mmGetById.mock.t.Fatalf("Some expectations are already set for the IOrderService.GetById method")
	}

	mmGetById.mock.funcGetById = f
	mmGetById.mock.funcGetByIdOrigin = minimock.CallerInfo(1)
	return mmGetById.mock
}

// When sets expectation for the IOrderService.GetById which will trigger the result defined by the following
// Then helper
func (mmGetById *mIOrderServiceMockGetById) When(ctx context.Context, o1 model.OID) *IOrderServiceMockGetByIdExpectation {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("IOrderServiceMock.GetById mock is already set by Set")
	}

	expectation := &IOrderServiceMockGetByIdExpectation{
		mock:               mmGetById.mock,
		params:             &IOrderServiceMockGetByIdParams{ctx, o1},
		expectationOrigins: IOrderServiceMockGetByIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetById.expectations = append(mmGetById.expectations, expectation)
	return expectation
}

// Then sets up IOrderService.GetById return parameters for the expectation previously defined by the When method
func (e *IOrderServiceMockGetByIdExpectation) Then(o2 model.Order, err error) *IOrderServiceMock {
	e.results = &IOrderServiceMockGetByIdResults{o2, err}
	return e.mock
}

// Times sets number of times IOrderService.GetById should be invoked
func (mmGetById *mIOrderServiceMockGetById) Times(n uint64) *mIOrderServiceMockGetById {
	if n == 0 {
		mmGetById.mock.t.Fatalf("Times of IOrderServiceMock.GetById mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetById.expectedInvocations, n)
	mmGetById.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetById
}

func (mmGetById *mIOrderServiceMockGetById) invocationsDone() bool {
	if len(mmGetById.expectations) == 0 && mmGetById.defaultExpectation == nil && mmGetById.mock.funcGetById == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetById.mock.afterGetByIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetById.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetById implements mm_loms_service.IOrderService
func (mmGetById *IOrderServiceMock) GetById(ctx context.Context, o1 model.OID) (o2 model.Order, err error) {
	mm_atomic.AddUint64(&mmGetById.beforeGetByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetById.afterGetByIdCounter, 1)

	mmGetById.t.Helper()

	if mmGetById.inspectFuncGetById != nil {
		mmGetById.inspectFuncGetById(ctx, o1)
	}

	mm_params := IOrderServiceMockGetByIdParams{ctx, o1}

	// Record call args
	mmGetById.GetByIdMock.mutex.Lock()
	mmGetById.GetByIdMock.callArgs = append(mmGetById.GetByIdMock.callArgs, &mm_params)
	mmGetById.GetByIdMock.mutex.Unlock()

	for _, e := range mmGetById.GetByIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o2, e.results.err
		}
	}

	if mmGetById.GetByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetById.GetByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetById.GetByIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetById.GetByIdMock.defaultExpectation.paramPtrs

		mm_got := IOrderServiceMockGetByIdParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetById.t.Errorf("IOrderServiceMock.GetById got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmGetById.t.Errorf("IOrderServiceMock.GetById got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetById.t.Errorf("IOrderServiceMock.GetById got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetById.GetByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetById.t.Fatal("No results are set for the IOrderServiceMock.GetById")
		}
		return (*mm_results).o2, (*mm_results).err
	}
	if mmGetById.funcGetById != nil {
		return mmGetById.funcGetById(ctx, o1)
	}
	mmGetById.t.Fatalf("Unexpected call to IOrderServiceMock.GetById. %v %v", ctx, o1)
	return
}

// GetByIdAfterCounter returns a count of finished IOrderServiceMock.GetById invocations
func (mmGetById *IOrderServiceMock) GetByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.afterGetByIdCounter)
}

// GetByIdBeforeCounter returns a count of IOrderServiceMock.GetById invocations
func (mmGetById *IOrderServiceMock) GetByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.beforeGetByIdCounter)
}

// Calls returns a list of arguments used in each call to IOrderServiceMock.GetById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetById *mIOrderServiceMockGetById) Calls() []*IOrderServiceMockGetByIdParams {
	mmGetById.mutex.RLock()

	argCopy := make([]*IOrderServiceMockGetByIdParams, len(mmGetById.callArgs))
	copy(argCopy, mmGetById.callArgs)

	mmGetById.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIdDone returns true if the count of the GetById invocations corresponds
// the number of defined expectations
func (m *IOrderServiceMock) MinimockGetByIdDone() bool {
	if m.GetByIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIdMock.invocationsDone()
}

// MinimockGetByIdInspect logs each unmet expectation
func (m *IOrderServiceMock) MinimockGetByIdInspect() {
	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderServiceMock.GetById at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIdCounter := mm_atomic.LoadUint64(&m.afterGetByIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIdMock.defaultExpectation != nil && afterGetByIdCounter < 1 {
		if m.GetByIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderServiceMock.GetById at\n%s", m.GetByIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderServiceMock.GetById at\n%s with params: %#v", m.GetByIdMock.defaultExpectation.expectationOrigins.origin, *m.GetByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetById != nil && afterGetByIdCounter < 1 {
		m.t.Errorf("Expected call to IOrderServiceMock.GetById at\n%s", m.funcGetByIdOrigin)
	}

	if !m.GetByIdMock.invocationsDone() && afterGetByIdCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderServiceMock.GetById at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIdMock.expectedInvocations), m.GetByIdMock.expectedInvocationsOrigin, afterGetByIdCounter)
	}
}

type mIOrderServiceMockSetStatus struct {
	optional           bool
	mock               *IOrderServiceMock
	defaultExpectation *IOrderServiceMockSetStatusExpectation
	expectations       []*IOrderServiceMockSetStatusExpectation

	callArgs []*IOrderServiceMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderServiceMockSetStatusExpectation specifies expectation struct of the IOrderService.SetStatus
type IOrderServiceMockSetStatusExpectation struct {
	mock               *IOrderServiceMock
	params             *IOrderServiceMockSetStatusParams
	paramPtrs          *IOrderServiceMockSetStatusParamPtrs
	expectationOrigins IOrderServiceMockSetStatusExpectationOrigins
	results            *IOrderServiceMockSetStatusResults
	returnOrigin       string
	Counter            uint64
}

// IOrderServiceMockSetStatusParams contains parameters of the IOrderService.SetStatus
type IOrderServiceMockSetStatusParams struct {
	ctx context.Context
	o1  model.OID
	s1  string
}

// IOrderServiceMockSetStatusParamPtrs contains pointers to parameters of the IOrderService.SetStatus
type IOrderServiceMockSetStatusParamPtrs struct {
	ctx *context.Context
	o1  *model.OID
	s1  *string
}

// IOrderServiceMockSetStatusResults contains results of the IOrderService.SetStatus
type IOrderServiceMockSetStatusResults struct {
	err error
}

// IOrderServiceMockSetStatusOrigins contains origins of expectations of the IOrderService.SetStatus
type IOrderServiceMockSetStatusExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mIOrderServiceMockSetStatus) Optional() *mIOrderServiceMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for IOrderService.SetStatus
func (mmSetStatus *mIOrderServiceMockSetStatus) Expect(ctx context.Context, o1 model.OID, s1 string) *mIOrderServiceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderServiceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &IOrderServiceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("IOrderServiceMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &IOrderServiceMockSetStatusParams{ctx, o1, s1}
	mmSetStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for IOrderService.SetStatus
func (mmSetStatus *mIOrderServiceMockSetStatus) ExpectCtxParam1(ctx context.Context) *mIOrderServiceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderServiceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &IOrderServiceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("IOrderServiceMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &IOrderServiceMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectO1Param2 sets up expected param o1 for IOrderService.SetStatus
func (mmSetStatus *mIOrderServiceMockSetStatus) ExpectO1Param2(o1 model.OID) *mIOrderServiceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderServiceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &IOrderServiceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("IOrderServiceMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &IOrderServiceMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.o1 = &o1
	mmSetStatus.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectS1Param3 sets up expected param s1 for IOrderService.SetStatus
func (mmSetStatus *mIOrderServiceMockSetStatus) ExpectS1Param3(s1 string) *mIOrderServiceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderServiceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &IOrderServiceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("IOrderServiceMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &IOrderServiceMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.s1 = &s1
	mmSetStatus.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the IOrderService.SetStatus
func (mmSetStatus *mIOrderServiceMockSetStatus) Inspect(f func(ctx context.Context, o1 model.OID, s1 string)) *mIOrderServiceMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for IOrderServiceMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by IOrderService.SetStatus
func (mmSetStatus *mIOrderServiceMockSetStatus) Return(err error) *IOrderServiceMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderServiceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &IOrderServiceMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &IOrderServiceMockSetStatusResults{err}
	mmSetStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// Set uses given function f to mock the IOrderService.SetStatus method
func (mmSetStatus *mIOrderServiceMockSetStatus) Set(f func(ctx context.Context, o1 model.OID, s1 string) (err error)) *IOrderServiceMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the IOrderService.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the IOrderService.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	mmSetStatus.mock.funcSetStatusOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// When sets expectation for the IOrderService.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mIOrderServiceMockSetStatus) When(ctx context.Context, o1 model.OID, s1 string) *IOrderServiceMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderServiceMock.SetStatus mock is already set by Set")
	}

	expectation := &IOrderServiceMockSetStatusExpectation{
		mock:               mmSetStatus.mock,
		params:             &IOrderServiceMockSetStatusParams{ctx, o1, s1},
		expectationOrigins: IOrderServiceMockSetStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up IOrderService.SetStatus return parameters for the expectation previously defined by the When method
func (e *IOrderServiceMockSetStatusExpectation) Then(err error) *IOrderServiceMock {
	e.results = &IOrderServiceMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times IOrderService.SetStatus should be invoked
func (mmSetStatus *mIOrderServiceMockSetStatus) Times(n uint64) *mIOrderServiceMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of IOrderServiceMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	mmSetStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatus
}

func (mmSetStatus *mIOrderServiceMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements mm_loms_service.IOrderService
func (mmSetStatus *IOrderServiceMock) SetStatus(ctx context.Context, o1 model.OID, s1 string) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	mmSetStatus.t.Helper()

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, o1, s1)
	}

	mm_params := IOrderServiceMockSetStatusParams{ctx, o1, s1}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := IOrderServiceMockSetStatusParams{ctx, o1, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("IOrderServiceMock.SetStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmSetStatus.t.Errorf("IOrderServiceMock.SetStatus got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmSetStatus.t.Errorf("IOrderServiceMock.SetStatus got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("IOrderServiceMock.SetStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the IOrderServiceMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, o1, s1)
	}
	mmSetStatus.t.Fatalf("Unexpected call to IOrderServiceMock.SetStatus. %v %v %v", ctx, o1, s1)
	return
}

// SetStatusAfterCounter returns a count of finished IOrderServiceMock.SetStatus invocations
func (mmSetStatus *IOrderServiceMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of IOrderServiceMock.SetStatus invocations
func (mmSetStatus *IOrderServiceMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to IOrderServiceMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mIOrderServiceMockSetStatus) Calls() []*IOrderServiceMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*IOrderServiceMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *IOrderServiceMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *IOrderServiceMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderServiceMock.SetStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderServiceMock.SetStatus at\n%s", m.SetStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderServiceMock.SetStatus at\n%s with params: %#v", m.SetStatusMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Errorf("Expected call to IOrderServiceMock.SetStatus at\n%s", m.funcSetStatusOrigin)
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderServiceMock.SetStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), m.SetStatusMock.expectedInvocationsOrigin, afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IOrderServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetByIdInspect()

			m.MinimockSetStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IOrderServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IOrderServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByIdDone() &&
		m.MinimockSetStatusDone()
}
