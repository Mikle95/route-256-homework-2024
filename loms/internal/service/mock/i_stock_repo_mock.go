// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/1mikle1/homework/loms/internal/service.IStockRepo -o i_stock_repo_mock_test.go -n IStockRepoMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/1mikle1/homework/loms/internal/model"
)

// IStockRepoMock implements mm_service.IStockRepo
type IStockRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetStock          func(ctx context.Context, s1 model.SKU) (s2 model.Stock, err error)
	funcGetStockOrigin    string
	inspectFuncGetStock   func(ctx context.Context, s1 model.SKU)
	afterGetStockCounter  uint64
	beforeGetStockCounter uint64
	GetStockMock          mIStockRepoMockGetStock

	funcInsertStock          func(ctx context.Context, s1 model.Stock) (err error)
	funcInsertStockOrigin    string
	inspectFuncInsertStock   func(ctx context.Context, s1 model.Stock)
	afterInsertStockCounter  uint64
	beforeInsertStockCounter uint64
	InsertStockMock          mIStockRepoMockInsertStock
}

// NewIStockRepoMock returns a mock for mm_service.IStockRepo
func NewIStockRepoMock(t minimock.Tester) *IStockRepoMock {
	m := &IStockRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetStockMock = mIStockRepoMockGetStock{mock: m}
	m.GetStockMock.callArgs = []*IStockRepoMockGetStockParams{}

	m.InsertStockMock = mIStockRepoMockInsertStock{mock: m}
	m.InsertStockMock.callArgs = []*IStockRepoMockInsertStockParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIStockRepoMockGetStock struct {
	optional           bool
	mock               *IStockRepoMock
	defaultExpectation *IStockRepoMockGetStockExpectation
	expectations       []*IStockRepoMockGetStockExpectation

	callArgs []*IStockRepoMockGetStockParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepoMockGetStockExpectation specifies expectation struct of the IStockRepo.GetStock
type IStockRepoMockGetStockExpectation struct {
	mock               *IStockRepoMock
	params             *IStockRepoMockGetStockParams
	paramPtrs          *IStockRepoMockGetStockParamPtrs
	expectationOrigins IStockRepoMockGetStockExpectationOrigins
	results            *IStockRepoMockGetStockResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepoMockGetStockParams contains parameters of the IStockRepo.GetStock
type IStockRepoMockGetStockParams struct {
	ctx context.Context
	s1  model.SKU
}

// IStockRepoMockGetStockParamPtrs contains pointers to parameters of the IStockRepo.GetStock
type IStockRepoMockGetStockParamPtrs struct {
	ctx *context.Context
	s1  *model.SKU
}

// IStockRepoMockGetStockResults contains results of the IStockRepo.GetStock
type IStockRepoMockGetStockResults struct {
	s2  model.Stock
	err error
}

// IStockRepoMockGetStockOrigins contains origins of expectations of the IStockRepo.GetStock
type IStockRepoMockGetStockExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStock *mIStockRepoMockGetStock) Optional() *mIStockRepoMockGetStock {
	mmGetStock.optional = true
	return mmGetStock
}

// Expect sets up expected params for IStockRepo.GetStock
func (mmGetStock *mIStockRepoMockGetStock) Expect(ctx context.Context, s1 model.SKU) *mIStockRepoMockGetStock {
	if mmGetStock.mock.funcGetStock != nil {
		mmGetStock.mock.t.Fatalf("IStockRepoMock.GetStock mock is already set by Set")
	}

	if mmGetStock.defaultExpectation == nil {
		mmGetStock.defaultExpectation = &IStockRepoMockGetStockExpectation{}
	}

	if mmGetStock.defaultExpectation.paramPtrs != nil {
		mmGetStock.mock.t.Fatalf("IStockRepoMock.GetStock mock is already set by ExpectParams functions")
	}

	mmGetStock.defaultExpectation.params = &IStockRepoMockGetStockParams{ctx, s1}
	mmGetStock.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStock.expectations {
		if minimock.Equal(e.params, mmGetStock.defaultExpectation.params) {
			mmGetStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStock.defaultExpectation.params)
		}
	}

	return mmGetStock
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepo.GetStock
func (mmGetStock *mIStockRepoMockGetStock) ExpectCtxParam1(ctx context.Context) *mIStockRepoMockGetStock {
	if mmGetStock.mock.funcGetStock != nil {
		mmGetStock.mock.t.Fatalf("IStockRepoMock.GetStock mock is already set by Set")
	}

	if mmGetStock.defaultExpectation == nil {
		mmGetStock.defaultExpectation = &IStockRepoMockGetStockExpectation{}
	}

	if mmGetStock.defaultExpectation.params != nil {
		mmGetStock.mock.t.Fatalf("IStockRepoMock.GetStock mock is already set by Expect")
	}

	if mmGetStock.defaultExpectation.paramPtrs == nil {
		mmGetStock.defaultExpectation.paramPtrs = &IStockRepoMockGetStockParamPtrs{}
	}
	mmGetStock.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStock.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStock
}

// ExpectS1Param2 sets up expected param s1 for IStockRepo.GetStock
func (mmGetStock *mIStockRepoMockGetStock) ExpectS1Param2(s1 model.SKU) *mIStockRepoMockGetStock {
	if mmGetStock.mock.funcGetStock != nil {
		mmGetStock.mock.t.Fatalf("IStockRepoMock.GetStock mock is already set by Set")
	}

	if mmGetStock.defaultExpectation == nil {
		mmGetStock.defaultExpectation = &IStockRepoMockGetStockExpectation{}
	}

	if mmGetStock.defaultExpectation.params != nil {
		mmGetStock.mock.t.Fatalf("IStockRepoMock.GetStock mock is already set by Expect")
	}

	if mmGetStock.defaultExpectation.paramPtrs == nil {
		mmGetStock.defaultExpectation.paramPtrs = &IStockRepoMockGetStockParamPtrs{}
	}
	mmGetStock.defaultExpectation.paramPtrs.s1 = &s1
	mmGetStock.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetStock
}

// Inspect accepts an inspector function that has same arguments as the IStockRepo.GetStock
func (mmGetStock *mIStockRepoMockGetStock) Inspect(f func(ctx context.Context, s1 model.SKU)) *mIStockRepoMockGetStock {
	if mmGetStock.mock.inspectFuncGetStock != nil {
		mmGetStock.mock.t.Fatalf("Inspect function is already set for IStockRepoMock.GetStock")
	}

	mmGetStock.mock.inspectFuncGetStock = f

	return mmGetStock
}

// Return sets up results that will be returned by IStockRepo.GetStock
func (mmGetStock *mIStockRepoMockGetStock) Return(s2 model.Stock, err error) *IStockRepoMock {
	if mmGetStock.mock.funcGetStock != nil {
		mmGetStock.mock.t.Fatalf("IStockRepoMock.GetStock mock is already set by Set")
	}

	if mmGetStock.defaultExpectation == nil {
		mmGetStock.defaultExpectation = &IStockRepoMockGetStockExpectation{mock: mmGetStock.mock}
	}
	mmGetStock.defaultExpectation.results = &IStockRepoMockGetStockResults{s2, err}
	mmGetStock.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStock.mock
}

// Set uses given function f to mock the IStockRepo.GetStock method
func (mmGetStock *mIStockRepoMockGetStock) Set(f func(ctx context.Context, s1 model.SKU) (s2 model.Stock, err error)) *IStockRepoMock {
	if mmGetStock.defaultExpectation != nil {
		mmGetStock.mock.t.Fatalf("Default expectation is already set for the IStockRepo.GetStock method")
	}

	if len(mmGetStock.expectations) > 0 {
		mmGetStock.mock.t.Fatalf("Some expectations are already set for the IStockRepo.GetStock method")
	}

	mmGetStock.mock.funcGetStock = f
	mmGetStock.mock.funcGetStockOrigin = minimock.CallerInfo(1)
	return mmGetStock.mock
}

// When sets expectation for the IStockRepo.GetStock which will trigger the result defined by the following
// Then helper
func (mmGetStock *mIStockRepoMockGetStock) When(ctx context.Context, s1 model.SKU) *IStockRepoMockGetStockExpectation {
	if mmGetStock.mock.funcGetStock != nil {
		mmGetStock.mock.t.Fatalf("IStockRepoMock.GetStock mock is already set by Set")
	}

	expectation := &IStockRepoMockGetStockExpectation{
		mock:               mmGetStock.mock,
		params:             &IStockRepoMockGetStockParams{ctx, s1},
		expectationOrigins: IStockRepoMockGetStockExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStock.expectations = append(mmGetStock.expectations, expectation)
	return expectation
}

// Then sets up IStockRepo.GetStock return parameters for the expectation previously defined by the When method
func (e *IStockRepoMockGetStockExpectation) Then(s2 model.Stock, err error) *IStockRepoMock {
	e.results = &IStockRepoMockGetStockResults{s2, err}
	return e.mock
}

// Times sets number of times IStockRepo.GetStock should be invoked
func (mmGetStock *mIStockRepoMockGetStock) Times(n uint64) *mIStockRepoMockGetStock {
	if n == 0 {
		mmGetStock.mock.t.Fatalf("Times of IStockRepoMock.GetStock mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStock.expectedInvocations, n)
	mmGetStock.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStock
}

func (mmGetStock *mIStockRepoMockGetStock) invocationsDone() bool {
	if len(mmGetStock.expectations) == 0 && mmGetStock.defaultExpectation == nil && mmGetStock.mock.funcGetStock == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStock.mock.afterGetStockCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStock.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStock implements mm_service.IStockRepo
func (mmGetStock *IStockRepoMock) GetStock(ctx context.Context, s1 model.SKU) (s2 model.Stock, err error) {
	mm_atomic.AddUint64(&mmGetStock.beforeGetStockCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStock.afterGetStockCounter, 1)

	mmGetStock.t.Helper()

	if mmGetStock.inspectFuncGetStock != nil {
		mmGetStock.inspectFuncGetStock(ctx, s1)
	}

	mm_params := IStockRepoMockGetStockParams{ctx, s1}

	// Record call args
	mmGetStock.GetStockMock.mutex.Lock()
	mmGetStock.GetStockMock.callArgs = append(mmGetStock.GetStockMock.callArgs, &mm_params)
	mmGetStock.GetStockMock.mutex.Unlock()

	for _, e := range mmGetStock.GetStockMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmGetStock.GetStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStock.GetStockMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStock.GetStockMock.defaultExpectation.params
		mm_want_ptrs := mmGetStock.GetStockMock.defaultExpectation.paramPtrs

		mm_got := IStockRepoMockGetStockParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStock.t.Errorf("IStockRepoMock.GetStock got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStock.GetStockMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetStock.t.Errorf("IStockRepoMock.GetStock got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStock.GetStockMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStock.t.Errorf("IStockRepoMock.GetStock got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStock.GetStockMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStock.GetStockMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStock.t.Fatal("No results are set for the IStockRepoMock.GetStock")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmGetStock.funcGetStock != nil {
		return mmGetStock.funcGetStock(ctx, s1)
	}
	mmGetStock.t.Fatalf("Unexpected call to IStockRepoMock.GetStock. %v %v", ctx, s1)
	return
}

// GetStockAfterCounter returns a count of finished IStockRepoMock.GetStock invocations
func (mmGetStock *IStockRepoMock) GetStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStock.afterGetStockCounter)
}

// GetStockBeforeCounter returns a count of IStockRepoMock.GetStock invocations
func (mmGetStock *IStockRepoMock) GetStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStock.beforeGetStockCounter)
}

// Calls returns a list of arguments used in each call to IStockRepoMock.GetStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStock *mIStockRepoMockGetStock) Calls() []*IStockRepoMockGetStockParams {
	mmGetStock.mutex.RLock()

	argCopy := make([]*IStockRepoMockGetStockParams, len(mmGetStock.callArgs))
	copy(argCopy, mmGetStock.callArgs)

	mmGetStock.mutex.RUnlock()

	return argCopy
}

// MinimockGetStockDone returns true if the count of the GetStock invocations corresponds
// the number of defined expectations
func (m *IStockRepoMock) MinimockGetStockDone() bool {
	if m.GetStockMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStockMock.invocationsDone()
}

// MinimockGetStockInspect logs each unmet expectation
func (m *IStockRepoMock) MinimockGetStockInspect() {
	for _, e := range m.GetStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepoMock.GetStock at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStockCounter := mm_atomic.LoadUint64(&m.afterGetStockCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStockMock.defaultExpectation != nil && afterGetStockCounter < 1 {
		if m.GetStockMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepoMock.GetStock at\n%s", m.GetStockMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepoMock.GetStock at\n%s with params: %#v", m.GetStockMock.defaultExpectation.expectationOrigins.origin, *m.GetStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStock != nil && afterGetStockCounter < 1 {
		m.t.Errorf("Expected call to IStockRepoMock.GetStock at\n%s", m.funcGetStockOrigin)
	}

	if !m.GetStockMock.invocationsDone() && afterGetStockCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepoMock.GetStock at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStockMock.expectedInvocations), m.GetStockMock.expectedInvocationsOrigin, afterGetStockCounter)
	}
}

type mIStockRepoMockInsertStock struct {
	optional           bool
	mock               *IStockRepoMock
	defaultExpectation *IStockRepoMockInsertStockExpectation
	expectations       []*IStockRepoMockInsertStockExpectation

	callArgs []*IStockRepoMockInsertStockParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepoMockInsertStockExpectation specifies expectation struct of the IStockRepo.InsertStock
type IStockRepoMockInsertStockExpectation struct {
	mock               *IStockRepoMock
	params             *IStockRepoMockInsertStockParams
	paramPtrs          *IStockRepoMockInsertStockParamPtrs
	expectationOrigins IStockRepoMockInsertStockExpectationOrigins
	results            *IStockRepoMockInsertStockResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepoMockInsertStockParams contains parameters of the IStockRepo.InsertStock
type IStockRepoMockInsertStockParams struct {
	ctx context.Context
	s1  model.Stock
}

// IStockRepoMockInsertStockParamPtrs contains pointers to parameters of the IStockRepo.InsertStock
type IStockRepoMockInsertStockParamPtrs struct {
	ctx *context.Context
	s1  *model.Stock
}

// IStockRepoMockInsertStockResults contains results of the IStockRepo.InsertStock
type IStockRepoMockInsertStockResults struct {
	err error
}

// IStockRepoMockInsertStockOrigins contains origins of expectations of the IStockRepo.InsertStock
type IStockRepoMockInsertStockExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertStock *mIStockRepoMockInsertStock) Optional() *mIStockRepoMockInsertStock {
	mmInsertStock.optional = true
	return mmInsertStock
}

// Expect sets up expected params for IStockRepo.InsertStock
func (mmInsertStock *mIStockRepoMockInsertStock) Expect(ctx context.Context, s1 model.Stock) *mIStockRepoMockInsertStock {
	if mmInsertStock.mock.funcInsertStock != nil {
		mmInsertStock.mock.t.Fatalf("IStockRepoMock.InsertStock mock is already set by Set")
	}

	if mmInsertStock.defaultExpectation == nil {
		mmInsertStock.defaultExpectation = &IStockRepoMockInsertStockExpectation{}
	}

	if mmInsertStock.defaultExpectation.paramPtrs != nil {
		mmInsertStock.mock.t.Fatalf("IStockRepoMock.InsertStock mock is already set by ExpectParams functions")
	}

	mmInsertStock.defaultExpectation.params = &IStockRepoMockInsertStockParams{ctx, s1}
	mmInsertStock.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertStock.expectations {
		if minimock.Equal(e.params, mmInsertStock.defaultExpectation.params) {
			mmInsertStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertStock.defaultExpectation.params)
		}
	}

	return mmInsertStock
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepo.InsertStock
func (mmInsertStock *mIStockRepoMockInsertStock) ExpectCtxParam1(ctx context.Context) *mIStockRepoMockInsertStock {
	if mmInsertStock.mock.funcInsertStock != nil {
		mmInsertStock.mock.t.Fatalf("IStockRepoMock.InsertStock mock is already set by Set")
	}

	if mmInsertStock.defaultExpectation == nil {
		mmInsertStock.defaultExpectation = &IStockRepoMockInsertStockExpectation{}
	}

	if mmInsertStock.defaultExpectation.params != nil {
		mmInsertStock.mock.t.Fatalf("IStockRepoMock.InsertStock mock is already set by Expect")
	}

	if mmInsertStock.defaultExpectation.paramPtrs == nil {
		mmInsertStock.defaultExpectation.paramPtrs = &IStockRepoMockInsertStockParamPtrs{}
	}
	mmInsertStock.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertStock.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertStock
}

// ExpectS1Param2 sets up expected param s1 for IStockRepo.InsertStock
func (mmInsertStock *mIStockRepoMockInsertStock) ExpectS1Param2(s1 model.Stock) *mIStockRepoMockInsertStock {
	if mmInsertStock.mock.funcInsertStock != nil {
		mmInsertStock.mock.t.Fatalf("IStockRepoMock.InsertStock mock is already set by Set")
	}

	if mmInsertStock.defaultExpectation == nil {
		mmInsertStock.defaultExpectation = &IStockRepoMockInsertStockExpectation{}
	}

	if mmInsertStock.defaultExpectation.params != nil {
		mmInsertStock.mock.t.Fatalf("IStockRepoMock.InsertStock mock is already set by Expect")
	}

	if mmInsertStock.defaultExpectation.paramPtrs == nil {
		mmInsertStock.defaultExpectation.paramPtrs = &IStockRepoMockInsertStockParamPtrs{}
	}
	mmInsertStock.defaultExpectation.paramPtrs.s1 = &s1
	mmInsertStock.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmInsertStock
}

// Inspect accepts an inspector function that has same arguments as the IStockRepo.InsertStock
func (mmInsertStock *mIStockRepoMockInsertStock) Inspect(f func(ctx context.Context, s1 model.Stock)) *mIStockRepoMockInsertStock {
	if mmInsertStock.mock.inspectFuncInsertStock != nil {
		mmInsertStock.mock.t.Fatalf("Inspect function is already set for IStockRepoMock.InsertStock")
	}

	mmInsertStock.mock.inspectFuncInsertStock = f

	return mmInsertStock
}

// Return sets up results that will be returned by IStockRepo.InsertStock
func (mmInsertStock *mIStockRepoMockInsertStock) Return(err error) *IStockRepoMock {
	if mmInsertStock.mock.funcInsertStock != nil {
		mmInsertStock.mock.t.Fatalf("IStockRepoMock.InsertStock mock is already set by Set")
	}

	if mmInsertStock.defaultExpectation == nil {
		mmInsertStock.defaultExpectation = &IStockRepoMockInsertStockExpectation{mock: mmInsertStock.mock}
	}
	mmInsertStock.defaultExpectation.results = &IStockRepoMockInsertStockResults{err}
	mmInsertStock.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertStock.mock
}

// Set uses given function f to mock the IStockRepo.InsertStock method
func (mmInsertStock *mIStockRepoMockInsertStock) Set(f func(ctx context.Context, s1 model.Stock) (err error)) *IStockRepoMock {
	if mmInsertStock.defaultExpectation != nil {
		mmInsertStock.mock.t.Fatalf("Default expectation is already set for the IStockRepo.InsertStock method")
	}

	if len(mmInsertStock.expectations) > 0 {
		mmInsertStock.mock.t.Fatalf("Some expectations are already set for the IStockRepo.InsertStock method")
	}

	mmInsertStock.mock.funcInsertStock = f
	mmInsertStock.mock.funcInsertStockOrigin = minimock.CallerInfo(1)
	return mmInsertStock.mock
}

// When sets expectation for the IStockRepo.InsertStock which will trigger the result defined by the following
// Then helper
func (mmInsertStock *mIStockRepoMockInsertStock) When(ctx context.Context, s1 model.Stock) *IStockRepoMockInsertStockExpectation {
	if mmInsertStock.mock.funcInsertStock != nil {
		mmInsertStock.mock.t.Fatalf("IStockRepoMock.InsertStock mock is already set by Set")
	}

	expectation := &IStockRepoMockInsertStockExpectation{
		mock:               mmInsertStock.mock,
		params:             &IStockRepoMockInsertStockParams{ctx, s1},
		expectationOrigins: IStockRepoMockInsertStockExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertStock.expectations = append(mmInsertStock.expectations, expectation)
	return expectation
}

// Then sets up IStockRepo.InsertStock return parameters for the expectation previously defined by the When method
func (e *IStockRepoMockInsertStockExpectation) Then(err error) *IStockRepoMock {
	e.results = &IStockRepoMockInsertStockResults{err}
	return e.mock
}

// Times sets number of times IStockRepo.InsertStock should be invoked
func (mmInsertStock *mIStockRepoMockInsertStock) Times(n uint64) *mIStockRepoMockInsertStock {
	if n == 0 {
		mmInsertStock.mock.t.Fatalf("Times of IStockRepoMock.InsertStock mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertStock.expectedInvocations, n)
	mmInsertStock.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertStock
}

func (mmInsertStock *mIStockRepoMockInsertStock) invocationsDone() bool {
	if len(mmInsertStock.expectations) == 0 && mmInsertStock.defaultExpectation == nil && mmInsertStock.mock.funcInsertStock == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertStock.mock.afterInsertStockCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertStock.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertStock implements mm_service.IStockRepo
func (mmInsertStock *IStockRepoMock) InsertStock(ctx context.Context, s1 model.Stock) (err error) {
	mm_atomic.AddUint64(&mmInsertStock.beforeInsertStockCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertStock.afterInsertStockCounter, 1)

	mmInsertStock.t.Helper()

	if mmInsertStock.inspectFuncInsertStock != nil {
		mmInsertStock.inspectFuncInsertStock(ctx, s1)
	}

	mm_params := IStockRepoMockInsertStockParams{ctx, s1}

	// Record call args
	mmInsertStock.InsertStockMock.mutex.Lock()
	mmInsertStock.InsertStockMock.callArgs = append(mmInsertStock.InsertStockMock.callArgs, &mm_params)
	mmInsertStock.InsertStockMock.mutex.Unlock()

	for _, e := range mmInsertStock.InsertStockMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertStock.InsertStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertStock.InsertStockMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertStock.InsertStockMock.defaultExpectation.params
		mm_want_ptrs := mmInsertStock.InsertStockMock.defaultExpectation.paramPtrs

		mm_got := IStockRepoMockInsertStockParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertStock.t.Errorf("IStockRepoMock.InsertStock got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertStock.InsertStockMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmInsertStock.t.Errorf("IStockRepoMock.InsertStock got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertStock.InsertStockMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertStock.t.Errorf("IStockRepoMock.InsertStock got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertStock.InsertStockMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertStock.InsertStockMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertStock.t.Fatal("No results are set for the IStockRepoMock.InsertStock")
		}
		return (*mm_results).err
	}
	if mmInsertStock.funcInsertStock != nil {
		return mmInsertStock.funcInsertStock(ctx, s1)
	}
	mmInsertStock.t.Fatalf("Unexpected call to IStockRepoMock.InsertStock. %v %v", ctx, s1)
	return
}

// InsertStockAfterCounter returns a count of finished IStockRepoMock.InsertStock invocations
func (mmInsertStock *IStockRepoMock) InsertStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertStock.afterInsertStockCounter)
}

// InsertStockBeforeCounter returns a count of IStockRepoMock.InsertStock invocations
func (mmInsertStock *IStockRepoMock) InsertStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertStock.beforeInsertStockCounter)
}

// Calls returns a list of arguments used in each call to IStockRepoMock.InsertStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertStock *mIStockRepoMockInsertStock) Calls() []*IStockRepoMockInsertStockParams {
	mmInsertStock.mutex.RLock()

	argCopy := make([]*IStockRepoMockInsertStockParams, len(mmInsertStock.callArgs))
	copy(argCopy, mmInsertStock.callArgs)

	mmInsertStock.mutex.RUnlock()

	return argCopy
}

// MinimockInsertStockDone returns true if the count of the InsertStock invocations corresponds
// the number of defined expectations
func (m *IStockRepoMock) MinimockInsertStockDone() bool {
	if m.InsertStockMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertStockMock.invocationsDone()
}

// MinimockInsertStockInspect logs each unmet expectation
func (m *IStockRepoMock) MinimockInsertStockInspect() {
	for _, e := range m.InsertStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepoMock.InsertStock at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertStockCounter := mm_atomic.LoadUint64(&m.afterInsertStockCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertStockMock.defaultExpectation != nil && afterInsertStockCounter < 1 {
		if m.InsertStockMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepoMock.InsertStock at\n%s", m.InsertStockMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepoMock.InsertStock at\n%s with params: %#v", m.InsertStockMock.defaultExpectation.expectationOrigins.origin, *m.InsertStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertStock != nil && afterInsertStockCounter < 1 {
		m.t.Errorf("Expected call to IStockRepoMock.InsertStock at\n%s", m.funcInsertStockOrigin)
	}

	if !m.InsertStockMock.invocationsDone() && afterInsertStockCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepoMock.InsertStock at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertStockMock.expectedInvocations), m.InsertStockMock.expectedInvocationsOrigin, afterInsertStockCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IStockRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetStockInspect()

			m.MinimockInsertStockInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IStockRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IStockRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetStockDone() &&
		m.MinimockInsertStockDone()
}
