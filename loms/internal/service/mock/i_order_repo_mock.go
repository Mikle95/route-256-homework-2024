// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/1mikle1/homework/loms/internal/service.IOrderRepo -o i_order_repo_mock_test.go -n IOrderRepoMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/1mikle1/homework/loms/internal/model"
)

// IOrderRepoMock implements mm_service.IOrderRepo
type IOrderRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOrder          func(ctx context.Context, o1 model.Order) (o2 model.OID, err error)
	funcAddOrderOrigin    string
	inspectFuncAddOrder   func(ctx context.Context, o1 model.Order)
	afterAddOrderCounter  uint64
	beforeAddOrderCounter uint64
	AddOrderMock          mIOrderRepoMockAddOrder

	funcChangeOrder          func(ctx context.Context, o1 model.OID, o2 model.Order) (err error)
	funcChangeOrderOrigin    string
	inspectFuncChangeOrder   func(ctx context.Context, o1 model.OID, o2 model.Order)
	afterChangeOrderCounter  uint64
	beforeChangeOrderCounter uint64
	ChangeOrderMock          mIOrderRepoMockChangeOrder

	funcGetOrder          func(ctx context.Context, o1 model.OID) (o2 model.Order, err error)
	funcGetOrderOrigin    string
	inspectFuncGetOrder   func(ctx context.Context, o1 model.OID)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mIOrderRepoMockGetOrder
}

// NewIOrderRepoMock returns a mock for mm_service.IOrderRepo
func NewIOrderRepoMock(t minimock.Tester) *IOrderRepoMock {
	m := &IOrderRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOrderMock = mIOrderRepoMockAddOrder{mock: m}
	m.AddOrderMock.callArgs = []*IOrderRepoMockAddOrderParams{}

	m.ChangeOrderMock = mIOrderRepoMockChangeOrder{mock: m}
	m.ChangeOrderMock.callArgs = []*IOrderRepoMockChangeOrderParams{}

	m.GetOrderMock = mIOrderRepoMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*IOrderRepoMockGetOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIOrderRepoMockAddOrder struct {
	optional           bool
	mock               *IOrderRepoMock
	defaultExpectation *IOrderRepoMockAddOrderExpectation
	expectations       []*IOrderRepoMockAddOrderExpectation

	callArgs []*IOrderRepoMockAddOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepoMockAddOrderExpectation specifies expectation struct of the IOrderRepo.AddOrder
type IOrderRepoMockAddOrderExpectation struct {
	mock               *IOrderRepoMock
	params             *IOrderRepoMockAddOrderParams
	paramPtrs          *IOrderRepoMockAddOrderParamPtrs
	expectationOrigins IOrderRepoMockAddOrderExpectationOrigins
	results            *IOrderRepoMockAddOrderResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepoMockAddOrderParams contains parameters of the IOrderRepo.AddOrder
type IOrderRepoMockAddOrderParams struct {
	ctx context.Context
	o1  model.Order
}

// IOrderRepoMockAddOrderParamPtrs contains pointers to parameters of the IOrderRepo.AddOrder
type IOrderRepoMockAddOrderParamPtrs struct {
	ctx *context.Context
	o1  *model.Order
}

// IOrderRepoMockAddOrderResults contains results of the IOrderRepo.AddOrder
type IOrderRepoMockAddOrderResults struct {
	o2  model.OID
	err error
}

// IOrderRepoMockAddOrderOrigins contains origins of expectations of the IOrderRepo.AddOrder
type IOrderRepoMockAddOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrder *mIOrderRepoMockAddOrder) Optional() *mIOrderRepoMockAddOrder {
	mmAddOrder.optional = true
	return mmAddOrder
}

// Expect sets up expected params for IOrderRepo.AddOrder
func (mmAddOrder *mIOrderRepoMockAddOrder) Expect(ctx context.Context, o1 model.Order) *mIOrderRepoMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("IOrderRepoMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &IOrderRepoMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.paramPtrs != nil {
		mmAddOrder.mock.t.Fatalf("IOrderRepoMock.AddOrder mock is already set by ExpectParams functions")
	}

	mmAddOrder.defaultExpectation.params = &IOrderRepoMockAddOrderParams{ctx, o1}
	mmAddOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrder.expectations {
		if minimock.Equal(e.params, mmAddOrder.defaultExpectation.params) {
			mmAddOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrder.defaultExpectation.params)
		}
	}

	return mmAddOrder
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepo.AddOrder
func (mmAddOrder *mIOrderRepoMockAddOrder) ExpectCtxParam1(ctx context.Context) *mIOrderRepoMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("IOrderRepoMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &IOrderRepoMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("IOrderRepoMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &IOrderRepoMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectO1Param2 sets up expected param o1 for IOrderRepo.AddOrder
func (mmAddOrder *mIOrderRepoMockAddOrder) ExpectO1Param2(o1 model.Order) *mIOrderRepoMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("IOrderRepoMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &IOrderRepoMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("IOrderRepoMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &IOrderRepoMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.o1 = &o1
	mmAddOrder.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmAddOrder
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepo.AddOrder
func (mmAddOrder *mIOrderRepoMockAddOrder) Inspect(f func(ctx context.Context, o1 model.Order)) *mIOrderRepoMockAddOrder {
	if mmAddOrder.mock.inspectFuncAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("Inspect function is already set for IOrderRepoMock.AddOrder")
	}

	mmAddOrder.mock.inspectFuncAddOrder = f

	return mmAddOrder
}

// Return sets up results that will be returned by IOrderRepo.AddOrder
func (mmAddOrder *mIOrderRepoMockAddOrder) Return(o2 model.OID, err error) *IOrderRepoMock {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("IOrderRepoMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &IOrderRepoMockAddOrderExpectation{mock: mmAddOrder.mock}
	}
	mmAddOrder.defaultExpectation.results = &IOrderRepoMockAddOrderResults{o2, err}
	mmAddOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// Set uses given function f to mock the IOrderRepo.AddOrder method
func (mmAddOrder *mIOrderRepoMockAddOrder) Set(f func(ctx context.Context, o1 model.Order) (o2 model.OID, err error)) *IOrderRepoMock {
	if mmAddOrder.defaultExpectation != nil {
		mmAddOrder.mock.t.Fatalf("Default expectation is already set for the IOrderRepo.AddOrder method")
	}

	if len(mmAddOrder.expectations) > 0 {
		mmAddOrder.mock.t.Fatalf("Some expectations are already set for the IOrderRepo.AddOrder method")
	}

	mmAddOrder.mock.funcAddOrder = f
	mmAddOrder.mock.funcAddOrderOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// When sets expectation for the IOrderRepo.AddOrder which will trigger the result defined by the following
// Then helper
func (mmAddOrder *mIOrderRepoMockAddOrder) When(ctx context.Context, o1 model.Order) *IOrderRepoMockAddOrderExpectation {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("IOrderRepoMock.AddOrder mock is already set by Set")
	}

	expectation := &IOrderRepoMockAddOrderExpectation{
		mock:               mmAddOrder.mock,
		params:             &IOrderRepoMockAddOrderParams{ctx, o1},
		expectationOrigins: IOrderRepoMockAddOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrder.expectations = append(mmAddOrder.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepo.AddOrder return parameters for the expectation previously defined by the When method
func (e *IOrderRepoMockAddOrderExpectation) Then(o2 model.OID, err error) *IOrderRepoMock {
	e.results = &IOrderRepoMockAddOrderResults{o2, err}
	return e.mock
}

// Times sets number of times IOrderRepo.AddOrder should be invoked
func (mmAddOrder *mIOrderRepoMockAddOrder) Times(n uint64) *mIOrderRepoMockAddOrder {
	if n == 0 {
		mmAddOrder.mock.t.Fatalf("Times of IOrderRepoMock.AddOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrder.expectedInvocations, n)
	mmAddOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrder
}

func (mmAddOrder *mIOrderRepoMockAddOrder) invocationsDone() bool {
	if len(mmAddOrder.expectations) == 0 && mmAddOrder.defaultExpectation == nil && mmAddOrder.mock.funcAddOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrder.mock.afterAddOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrder implements mm_service.IOrderRepo
func (mmAddOrder *IOrderRepoMock) AddOrder(ctx context.Context, o1 model.Order) (o2 model.OID, err error) {
	mm_atomic.AddUint64(&mmAddOrder.beforeAddOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrder.afterAddOrderCounter, 1)

	mmAddOrder.t.Helper()

	if mmAddOrder.inspectFuncAddOrder != nil {
		mmAddOrder.inspectFuncAddOrder(ctx, o1)
	}

	mm_params := IOrderRepoMockAddOrderParams{ctx, o1}

	// Record call args
	mmAddOrder.AddOrderMock.mutex.Lock()
	mmAddOrder.AddOrderMock.callArgs = append(mmAddOrder.AddOrderMock.callArgs, &mm_params)
	mmAddOrder.AddOrderMock.mutex.Unlock()

	for _, e := range mmAddOrder.AddOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o2, e.results.err
		}
	}

	if mmAddOrder.AddOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrder.AddOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrder.AddOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrder.AddOrderMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepoMockAddOrderParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOrder.t.Errorf("IOrderRepoMock.AddOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmAddOrder.t.Errorf("IOrderRepoMock.AddOrder got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrder.t.Errorf("IOrderRepoMock.AddOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrder.AddOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrder.t.Fatal("No results are set for the IOrderRepoMock.AddOrder")
		}
		return (*mm_results).o2, (*mm_results).err
	}
	if mmAddOrder.funcAddOrder != nil {
		return mmAddOrder.funcAddOrder(ctx, o1)
	}
	mmAddOrder.t.Fatalf("Unexpected call to IOrderRepoMock.AddOrder. %v %v", ctx, o1)
	return
}

// AddOrderAfterCounter returns a count of finished IOrderRepoMock.AddOrder invocations
func (mmAddOrder *IOrderRepoMock) AddOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.afterAddOrderCounter)
}

// AddOrderBeforeCounter returns a count of IOrderRepoMock.AddOrder invocations
func (mmAddOrder *IOrderRepoMock) AddOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.beforeAddOrderCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepoMock.AddOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrder *mIOrderRepoMockAddOrder) Calls() []*IOrderRepoMockAddOrderParams {
	mmAddOrder.mutex.RLock()

	argCopy := make([]*IOrderRepoMockAddOrderParams, len(mmAddOrder.callArgs))
	copy(argCopy, mmAddOrder.callArgs)

	mmAddOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderDone returns true if the count of the AddOrder invocations corresponds
// the number of defined expectations
func (m *IOrderRepoMock) MinimockAddOrderDone() bool {
	if m.AddOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderMock.invocationsDone()
}

// MinimockAddOrderInspect logs each unmet expectation
func (m *IOrderRepoMock) MinimockAddOrderInspect() {
	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepoMock.AddOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderCounter := mm_atomic.LoadUint64(&m.afterAddOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderMock.defaultExpectation != nil && afterAddOrderCounter < 1 {
		if m.AddOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepoMock.AddOrder at\n%s", m.AddOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepoMock.AddOrder at\n%s with params: %#v", m.AddOrderMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrder != nil && afterAddOrderCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepoMock.AddOrder at\n%s", m.funcAddOrderOrigin)
	}

	if !m.AddOrderMock.invocationsDone() && afterAddOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepoMock.AddOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderMock.expectedInvocations), m.AddOrderMock.expectedInvocationsOrigin, afterAddOrderCounter)
	}
}

type mIOrderRepoMockChangeOrder struct {
	optional           bool
	mock               *IOrderRepoMock
	defaultExpectation *IOrderRepoMockChangeOrderExpectation
	expectations       []*IOrderRepoMockChangeOrderExpectation

	callArgs []*IOrderRepoMockChangeOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepoMockChangeOrderExpectation specifies expectation struct of the IOrderRepo.ChangeOrder
type IOrderRepoMockChangeOrderExpectation struct {
	mock               *IOrderRepoMock
	params             *IOrderRepoMockChangeOrderParams
	paramPtrs          *IOrderRepoMockChangeOrderParamPtrs
	expectationOrigins IOrderRepoMockChangeOrderExpectationOrigins
	results            *IOrderRepoMockChangeOrderResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepoMockChangeOrderParams contains parameters of the IOrderRepo.ChangeOrder
type IOrderRepoMockChangeOrderParams struct {
	ctx context.Context
	o1  model.OID
	o2  model.Order
}

// IOrderRepoMockChangeOrderParamPtrs contains pointers to parameters of the IOrderRepo.ChangeOrder
type IOrderRepoMockChangeOrderParamPtrs struct {
	ctx *context.Context
	o1  *model.OID
	o2  *model.Order
}

// IOrderRepoMockChangeOrderResults contains results of the IOrderRepo.ChangeOrder
type IOrderRepoMockChangeOrderResults struct {
	err error
}

// IOrderRepoMockChangeOrderOrigins contains origins of expectations of the IOrderRepo.ChangeOrder
type IOrderRepoMockChangeOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
	originO2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChangeOrder *mIOrderRepoMockChangeOrder) Optional() *mIOrderRepoMockChangeOrder {
	mmChangeOrder.optional = true
	return mmChangeOrder
}

// Expect sets up expected params for IOrderRepo.ChangeOrder
func (mmChangeOrder *mIOrderRepoMockChangeOrder) Expect(ctx context.Context, o1 model.OID, o2 model.Order) *mIOrderRepoMockChangeOrder {
	if mmChangeOrder.mock.funcChangeOrder != nil {
		mmChangeOrder.mock.t.Fatalf("IOrderRepoMock.ChangeOrder mock is already set by Set")
	}

	if mmChangeOrder.defaultExpectation == nil {
		mmChangeOrder.defaultExpectation = &IOrderRepoMockChangeOrderExpectation{}
	}

	if mmChangeOrder.defaultExpectation.paramPtrs != nil {
		mmChangeOrder.mock.t.Fatalf("IOrderRepoMock.ChangeOrder mock is already set by ExpectParams functions")
	}

	mmChangeOrder.defaultExpectation.params = &IOrderRepoMockChangeOrderParams{ctx, o1, o2}
	mmChangeOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChangeOrder.expectations {
		if minimock.Equal(e.params, mmChangeOrder.defaultExpectation.params) {
			mmChangeOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangeOrder.defaultExpectation.params)
		}
	}

	return mmChangeOrder
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepo.ChangeOrder
func (mmChangeOrder *mIOrderRepoMockChangeOrder) ExpectCtxParam1(ctx context.Context) *mIOrderRepoMockChangeOrder {
	if mmChangeOrder.mock.funcChangeOrder != nil {
		mmChangeOrder.mock.t.Fatalf("IOrderRepoMock.ChangeOrder mock is already set by Set")
	}

	if mmChangeOrder.defaultExpectation == nil {
		mmChangeOrder.defaultExpectation = &IOrderRepoMockChangeOrderExpectation{}
	}

	if mmChangeOrder.defaultExpectation.params != nil {
		mmChangeOrder.mock.t.Fatalf("IOrderRepoMock.ChangeOrder mock is already set by Expect")
	}

	if mmChangeOrder.defaultExpectation.paramPtrs == nil {
		mmChangeOrder.defaultExpectation.paramPtrs = &IOrderRepoMockChangeOrderParamPtrs{}
	}
	mmChangeOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmChangeOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChangeOrder
}

// ExpectO1Param2 sets up expected param o1 for IOrderRepo.ChangeOrder
func (mmChangeOrder *mIOrderRepoMockChangeOrder) ExpectO1Param2(o1 model.OID) *mIOrderRepoMockChangeOrder {
	if mmChangeOrder.mock.funcChangeOrder != nil {
		mmChangeOrder.mock.t.Fatalf("IOrderRepoMock.ChangeOrder mock is already set by Set")
	}

	if mmChangeOrder.defaultExpectation == nil {
		mmChangeOrder.defaultExpectation = &IOrderRepoMockChangeOrderExpectation{}
	}

	if mmChangeOrder.defaultExpectation.params != nil {
		mmChangeOrder.mock.t.Fatalf("IOrderRepoMock.ChangeOrder mock is already set by Expect")
	}

	if mmChangeOrder.defaultExpectation.paramPtrs == nil {
		mmChangeOrder.defaultExpectation.paramPtrs = &IOrderRepoMockChangeOrderParamPtrs{}
	}
	mmChangeOrder.defaultExpectation.paramPtrs.o1 = &o1
	mmChangeOrder.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmChangeOrder
}

// ExpectO2Param3 sets up expected param o2 for IOrderRepo.ChangeOrder
func (mmChangeOrder *mIOrderRepoMockChangeOrder) ExpectO2Param3(o2 model.Order) *mIOrderRepoMockChangeOrder {
	if mmChangeOrder.mock.funcChangeOrder != nil {
		mmChangeOrder.mock.t.Fatalf("IOrderRepoMock.ChangeOrder mock is already set by Set")
	}

	if mmChangeOrder.defaultExpectation == nil {
		mmChangeOrder.defaultExpectation = &IOrderRepoMockChangeOrderExpectation{}
	}

	if mmChangeOrder.defaultExpectation.params != nil {
		mmChangeOrder.mock.t.Fatalf("IOrderRepoMock.ChangeOrder mock is already set by Expect")
	}

	if mmChangeOrder.defaultExpectation.paramPtrs == nil {
		mmChangeOrder.defaultExpectation.paramPtrs = &IOrderRepoMockChangeOrderParamPtrs{}
	}
	mmChangeOrder.defaultExpectation.paramPtrs.o2 = &o2
	mmChangeOrder.defaultExpectation.expectationOrigins.originO2 = minimock.CallerInfo(1)

	return mmChangeOrder
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepo.ChangeOrder
func (mmChangeOrder *mIOrderRepoMockChangeOrder) Inspect(f func(ctx context.Context, o1 model.OID, o2 model.Order)) *mIOrderRepoMockChangeOrder {
	if mmChangeOrder.mock.inspectFuncChangeOrder != nil {
		mmChangeOrder.mock.t.Fatalf("Inspect function is already set for IOrderRepoMock.ChangeOrder")
	}

	mmChangeOrder.mock.inspectFuncChangeOrder = f

	return mmChangeOrder
}

// Return sets up results that will be returned by IOrderRepo.ChangeOrder
func (mmChangeOrder *mIOrderRepoMockChangeOrder) Return(err error) *IOrderRepoMock {
	if mmChangeOrder.mock.funcChangeOrder != nil {
		mmChangeOrder.mock.t.Fatalf("IOrderRepoMock.ChangeOrder mock is already set by Set")
	}

	if mmChangeOrder.defaultExpectation == nil {
		mmChangeOrder.defaultExpectation = &IOrderRepoMockChangeOrderExpectation{mock: mmChangeOrder.mock}
	}
	mmChangeOrder.defaultExpectation.results = &IOrderRepoMockChangeOrderResults{err}
	mmChangeOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChangeOrder.mock
}

// Set uses given function f to mock the IOrderRepo.ChangeOrder method
func (mmChangeOrder *mIOrderRepoMockChangeOrder) Set(f func(ctx context.Context, o1 model.OID, o2 model.Order) (err error)) *IOrderRepoMock {
	if mmChangeOrder.defaultExpectation != nil {
		mmChangeOrder.mock.t.Fatalf("Default expectation is already set for the IOrderRepo.ChangeOrder method")
	}

	if len(mmChangeOrder.expectations) > 0 {
		mmChangeOrder.mock.t.Fatalf("Some expectations are already set for the IOrderRepo.ChangeOrder method")
	}

	mmChangeOrder.mock.funcChangeOrder = f
	mmChangeOrder.mock.funcChangeOrderOrigin = minimock.CallerInfo(1)
	return mmChangeOrder.mock
}

// When sets expectation for the IOrderRepo.ChangeOrder which will trigger the result defined by the following
// Then helper
func (mmChangeOrder *mIOrderRepoMockChangeOrder) When(ctx context.Context, o1 model.OID, o2 model.Order) *IOrderRepoMockChangeOrderExpectation {
	if mmChangeOrder.mock.funcChangeOrder != nil {
		mmChangeOrder.mock.t.Fatalf("IOrderRepoMock.ChangeOrder mock is already set by Set")
	}

	expectation := &IOrderRepoMockChangeOrderExpectation{
		mock:               mmChangeOrder.mock,
		params:             &IOrderRepoMockChangeOrderParams{ctx, o1, o2},
		expectationOrigins: IOrderRepoMockChangeOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChangeOrder.expectations = append(mmChangeOrder.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepo.ChangeOrder return parameters for the expectation previously defined by the When method
func (e *IOrderRepoMockChangeOrderExpectation) Then(err error) *IOrderRepoMock {
	e.results = &IOrderRepoMockChangeOrderResults{err}
	return e.mock
}

// Times sets number of times IOrderRepo.ChangeOrder should be invoked
func (mmChangeOrder *mIOrderRepoMockChangeOrder) Times(n uint64) *mIOrderRepoMockChangeOrder {
	if n == 0 {
		mmChangeOrder.mock.t.Fatalf("Times of IOrderRepoMock.ChangeOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChangeOrder.expectedInvocations, n)
	mmChangeOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChangeOrder
}

func (mmChangeOrder *mIOrderRepoMockChangeOrder) invocationsDone() bool {
	if len(mmChangeOrder.expectations) == 0 && mmChangeOrder.defaultExpectation == nil && mmChangeOrder.mock.funcChangeOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChangeOrder.mock.afterChangeOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChangeOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChangeOrder implements mm_service.IOrderRepo
func (mmChangeOrder *IOrderRepoMock) ChangeOrder(ctx context.Context, o1 model.OID, o2 model.Order) (err error) {
	mm_atomic.AddUint64(&mmChangeOrder.beforeChangeOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmChangeOrder.afterChangeOrderCounter, 1)

	mmChangeOrder.t.Helper()

	if mmChangeOrder.inspectFuncChangeOrder != nil {
		mmChangeOrder.inspectFuncChangeOrder(ctx, o1, o2)
	}

	mm_params := IOrderRepoMockChangeOrderParams{ctx, o1, o2}

	// Record call args
	mmChangeOrder.ChangeOrderMock.mutex.Lock()
	mmChangeOrder.ChangeOrderMock.callArgs = append(mmChangeOrder.ChangeOrderMock.callArgs, &mm_params)
	mmChangeOrder.ChangeOrderMock.mutex.Unlock()

	for _, e := range mmChangeOrder.ChangeOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChangeOrder.ChangeOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangeOrder.ChangeOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmChangeOrder.ChangeOrderMock.defaultExpectation.params
		mm_want_ptrs := mmChangeOrder.ChangeOrderMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepoMockChangeOrderParams{ctx, o1, o2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChangeOrder.t.Errorf("IOrderRepoMock.ChangeOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangeOrder.ChangeOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmChangeOrder.t.Errorf("IOrderRepoMock.ChangeOrder got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangeOrder.ChangeOrderMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.o2 != nil && !minimock.Equal(*mm_want_ptrs.o2, mm_got.o2) {
				mmChangeOrder.t.Errorf("IOrderRepoMock.ChangeOrder got unexpected parameter o2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangeOrder.ChangeOrderMock.defaultExpectation.expectationOrigins.originO2, *mm_want_ptrs.o2, mm_got.o2, minimock.Diff(*mm_want_ptrs.o2, mm_got.o2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangeOrder.t.Errorf("IOrderRepoMock.ChangeOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChangeOrder.ChangeOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangeOrder.ChangeOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmChangeOrder.t.Fatal("No results are set for the IOrderRepoMock.ChangeOrder")
		}
		return (*mm_results).err
	}
	if mmChangeOrder.funcChangeOrder != nil {
		return mmChangeOrder.funcChangeOrder(ctx, o1, o2)
	}
	mmChangeOrder.t.Fatalf("Unexpected call to IOrderRepoMock.ChangeOrder. %v %v %v", ctx, o1, o2)
	return
}

// ChangeOrderAfterCounter returns a count of finished IOrderRepoMock.ChangeOrder invocations
func (mmChangeOrder *IOrderRepoMock) ChangeOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeOrder.afterChangeOrderCounter)
}

// ChangeOrderBeforeCounter returns a count of IOrderRepoMock.ChangeOrder invocations
func (mmChangeOrder *IOrderRepoMock) ChangeOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeOrder.beforeChangeOrderCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepoMock.ChangeOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangeOrder *mIOrderRepoMockChangeOrder) Calls() []*IOrderRepoMockChangeOrderParams {
	mmChangeOrder.mutex.RLock()

	argCopy := make([]*IOrderRepoMockChangeOrderParams, len(mmChangeOrder.callArgs))
	copy(argCopy, mmChangeOrder.callArgs)

	mmChangeOrder.mutex.RUnlock()

	return argCopy
}

// MinimockChangeOrderDone returns true if the count of the ChangeOrder invocations corresponds
// the number of defined expectations
func (m *IOrderRepoMock) MinimockChangeOrderDone() bool {
	if m.ChangeOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChangeOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChangeOrderMock.invocationsDone()
}

// MinimockChangeOrderInspect logs each unmet expectation
func (m *IOrderRepoMock) MinimockChangeOrderInspect() {
	for _, e := range m.ChangeOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepoMock.ChangeOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChangeOrderCounter := mm_atomic.LoadUint64(&m.afterChangeOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeOrderMock.defaultExpectation != nil && afterChangeOrderCounter < 1 {
		if m.ChangeOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepoMock.ChangeOrder at\n%s", m.ChangeOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepoMock.ChangeOrder at\n%s with params: %#v", m.ChangeOrderMock.defaultExpectation.expectationOrigins.origin, *m.ChangeOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeOrder != nil && afterChangeOrderCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepoMock.ChangeOrder at\n%s", m.funcChangeOrderOrigin)
	}

	if !m.ChangeOrderMock.invocationsDone() && afterChangeOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepoMock.ChangeOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChangeOrderMock.expectedInvocations), m.ChangeOrderMock.expectedInvocationsOrigin, afterChangeOrderCounter)
	}
}

type mIOrderRepoMockGetOrder struct {
	optional           bool
	mock               *IOrderRepoMock
	defaultExpectation *IOrderRepoMockGetOrderExpectation
	expectations       []*IOrderRepoMockGetOrderExpectation

	callArgs []*IOrderRepoMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepoMockGetOrderExpectation specifies expectation struct of the IOrderRepo.GetOrder
type IOrderRepoMockGetOrderExpectation struct {
	mock               *IOrderRepoMock
	params             *IOrderRepoMockGetOrderParams
	paramPtrs          *IOrderRepoMockGetOrderParamPtrs
	expectationOrigins IOrderRepoMockGetOrderExpectationOrigins
	results            *IOrderRepoMockGetOrderResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepoMockGetOrderParams contains parameters of the IOrderRepo.GetOrder
type IOrderRepoMockGetOrderParams struct {
	ctx context.Context
	o1  model.OID
}

// IOrderRepoMockGetOrderParamPtrs contains pointers to parameters of the IOrderRepo.GetOrder
type IOrderRepoMockGetOrderParamPtrs struct {
	ctx *context.Context
	o1  *model.OID
}

// IOrderRepoMockGetOrderResults contains results of the IOrderRepo.GetOrder
type IOrderRepoMockGetOrderResults struct {
	o2  model.Order
	err error
}

// IOrderRepoMockGetOrderOrigins contains origins of expectations of the IOrderRepo.GetOrder
type IOrderRepoMockGetOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mIOrderRepoMockGetOrder) Optional() *mIOrderRepoMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for IOrderRepo.GetOrder
func (mmGetOrder *mIOrderRepoMockGetOrder) Expect(ctx context.Context, o1 model.OID) *mIOrderRepoMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("IOrderRepoMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &IOrderRepoMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("IOrderRepoMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &IOrderRepoMockGetOrderParams{ctx, o1}
	mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepo.GetOrder
func (mmGetOrder *mIOrderRepoMockGetOrder) ExpectCtxParam1(ctx context.Context) *mIOrderRepoMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("IOrderRepoMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &IOrderRepoMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("IOrderRepoMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &IOrderRepoMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrder
}

// ExpectO1Param2 sets up expected param o1 for IOrderRepo.GetOrder
func (mmGetOrder *mIOrderRepoMockGetOrder) ExpectO1Param2(o1 model.OID) *mIOrderRepoMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("IOrderRepoMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &IOrderRepoMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("IOrderRepoMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &IOrderRepoMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.o1 = &o1
	mmGetOrder.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepo.GetOrder
func (mmGetOrder *mIOrderRepoMockGetOrder) Inspect(f func(ctx context.Context, o1 model.OID)) *mIOrderRepoMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for IOrderRepoMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by IOrderRepo.GetOrder
func (mmGetOrder *mIOrderRepoMockGetOrder) Return(o2 model.Order, err error) *IOrderRepoMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("IOrderRepoMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &IOrderRepoMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &IOrderRepoMockGetOrderResults{o2, err}
	mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// Set uses given function f to mock the IOrderRepo.GetOrder method
func (mmGetOrder *mIOrderRepoMockGetOrder) Set(f func(ctx context.Context, o1 model.OID) (o2 model.Order, err error)) *IOrderRepoMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the IOrderRepo.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the IOrderRepo.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// When sets expectation for the IOrderRepo.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mIOrderRepoMockGetOrder) When(ctx context.Context, o1 model.OID) *IOrderRepoMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("IOrderRepoMock.GetOrder mock is already set by Set")
	}

	expectation := &IOrderRepoMockGetOrderExpectation{
		mock:               mmGetOrder.mock,
		params:             &IOrderRepoMockGetOrderParams{ctx, o1},
		expectationOrigins: IOrderRepoMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepo.GetOrder return parameters for the expectation previously defined by the When method
func (e *IOrderRepoMockGetOrderExpectation) Then(o2 model.Order, err error) *IOrderRepoMock {
	e.results = &IOrderRepoMockGetOrderResults{o2, err}
	return e.mock
}

// Times sets number of times IOrderRepo.GetOrder should be invoked
func (mmGetOrder *mIOrderRepoMockGetOrder) Times(n uint64) *mIOrderRepoMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of IOrderRepoMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrder
}

func (mmGetOrder *mIOrderRepoMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements mm_service.IOrderRepo
func (mmGetOrder *IOrderRepoMock) GetOrder(ctx context.Context, o1 model.OID) (o2 model.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	mmGetOrder.t.Helper()

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, o1)
	}

	mm_params := IOrderRepoMockGetOrderParams{ctx, o1}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o2, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepoMockGetOrderParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrder.t.Errorf("IOrderRepoMock.GetOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmGetOrder.t.Errorf("IOrderRepoMock.GetOrder got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("IOrderRepoMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the IOrderRepoMock.GetOrder")
		}
		return (*mm_results).o2, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, o1)
	}
	mmGetOrder.t.Fatalf("Unexpected call to IOrderRepoMock.GetOrder. %v %v", ctx, o1)
	return
}

// GetOrderAfterCounter returns a count of finished IOrderRepoMock.GetOrder invocations
func (mmGetOrder *IOrderRepoMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of IOrderRepoMock.GetOrder invocations
func (mmGetOrder *IOrderRepoMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepoMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mIOrderRepoMockGetOrder) Calls() []*IOrderRepoMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*IOrderRepoMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *IOrderRepoMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *IOrderRepoMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepoMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepoMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepoMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepoMock.GetOrder at\n%s", m.funcGetOrderOrigin)
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepoMock.GetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IOrderRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOrderInspect()

			m.MinimockChangeOrderInspect()

			m.MinimockGetOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IOrderRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IOrderRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOrderDone() &&
		m.MinimockChangeOrderDone() &&
		m.MinimockGetOrderDone()
}
